#
# Node Interface
#

interface Node {
  id: ID!
  createdAt: DateTime! @search
  createdBy: User!

  parent: Node # If parent is null, Node is a root node !
  children: [Node!] @hasInverse(field: parent)

  name: String! @search(by: [term])
  nameid: String! @id
  mandate: Mandate
  # validatedBy  # @DEBUG: Birth logics?

  tensions_out: [Tension!] @hasInverse(field: emitter)
  tensions_in: [Tension!] # no bidirectional
}

# Supernode/Hyperedge
type Circle implements Node {
  isRoot: Boolean!

  #n_child: Int!    #
  #n_circles: Int!  # @DEBUG: remove and compute instead (will be cached anyway?)
  #n_roles: Int!    #
}

# Leaf
type Role implements Node {
  user: User
  second: User
  skills: [String!] @search(by: [term])
  #authority: Authority
}

#
# Post Interface
#

interface Post {
  id: ID!
  createdAt: DateTime! @search
  createdBy: User!
  message: String @search(by: [fulltext])
}

type Tension implements Post {
  nth: Int! # @id
  title: String! @search(by: [term])
  type_: TensionType! @search(by: [hash])
  emitter: Node!
  receivers: [Node!]
  isAnonymous: Boolean!
  severity: Int!
  comments: [Post!]

  #n_comments: Int!
}

type Mandate implements Post {
  purpose: String! @search(by: [fulltext])
  responsabilities: String
  domains: [String!] # new type v2?
  # Interface:
  #    period:
  #    canValidateNode
  #    number of validation to be modified ? ....
  #    election ???
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime! @search
  username: String! @id      @input_maxLength(n: 42, f: "username")
  fullname: String           @input_maxLength(n: 100, f: "fullname")
  password: String! @hidden  @input_maxLength(n: 42, f: "password")
  roles: [Role!] @hasInverse(field: user)
  backed_roles: [Role!] @hasInverse(field: second)
  bio: String
  #skills
}



#
# Enum
#

enum NodeType {
  Circle
  Role
}

enum TensionType {
  Governance
  Operational
  Personal
  Help
  Alert # BotAlert
}
