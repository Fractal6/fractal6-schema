directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @id(interface: Boolean) on FIELD_DEFINITION

directive @auth(password: AuthRule, query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT | INTERFACE

directive @cacheControl(maxAge: Int!) on QUERY

directive @generate(query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT | INTERFACE

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @cascade(fields: [String]) on FIELD

directive @default(add: DgraphDefault, update: DgraphDefault) on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

input AddBlobInput {
  createdAt: DateTime!
  message: String
  md: String
}

type AddBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Blob implements Post {
  createdAt: DateTime!
  message: String
  md: String
}

type BlobAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  messageMin: String
  messageMax: String
  mdMin: String
  mdMax: String
}

input BlobFilter {
  has: [BlobHasFilter]
  and: [BlobFilter]
  or: [BlobFilter]
  not: BlobFilter
}

enum BlobHasFilter {
  createdAt
  message
  md
}

input BlobOrder {
  asc: BlobOrderable
  desc: BlobOrderable
  then: BlobOrder
}

enum BlobOrderable {
  createdAt
  message
  md
}

input BlobPatch {
  createdAt: DateTime
  message: String
  md: String
}

input BlobRef {
  createdAt: DateTime
  message: String
  md: String
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds
after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  msg: String
  numUids: Int
}

type DeletePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  msg: String
  numUids: Int
}

input DgraphDefault {
  value: String
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  deletePost(filter: PostFilter!): DeletePostPayload
  addBlob(input: [AddBlobInput!]!): AddBlobPayload
  updateBlob(input: UpdateBlobInput!): UpdateBlobPayload
  deleteBlob(filter: BlobFilter!): DeleteBlobPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

interface Post {
  createdAt: DateTime!
  message: String
}

type PostAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  messageMin: String
  messageMax: String
}

input PostFilter {
  has: [PostHasFilter]
  and: [PostFilter]
  or: [PostFilter]
  not: PostFilter
}

enum PostHasFilter {
  createdAt
  message
}

input PostOrder {
  asc: PostOrderable
  desc: PostOrderable
  then: PostOrder
}

enum PostOrderable {
  createdAt
  message
}

input PostPatch {
  createdAt: DateTime
  message: String
}

type Query {
  queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  aggregatePost(filter: PostFilter): PostAggregateResult
  queryBlob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  aggregateBlob(filter: BlobFilter): BlobAggregateResult
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

input UpdateBlobInput {
  filter: BlobFilter!
  set: BlobPatch
  remove: BlobPatch
}

type UpdateBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input UpdatePostInput {
  filter: PostFilter!
  set: PostPatch
  remove: PostPatch
}

type UpdatePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  numUids: Int
}

input WithinFilter {
  polygon: PolygonRef!
}

