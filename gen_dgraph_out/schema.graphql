directive @cacheControl(maxAge: Int!) on QUERY

directive @generate(query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT | INTERFACE

directive @cascade(fields: [String]) on FIELD

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @auth(password: AuthRule, query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT | INTERFACE

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION

input AddBlobInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  tension: TensionRef!
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

type AddBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input AddCommentInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  _VOID: String
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input AddContractInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  tension: TensionRef!
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event: EventFragmentRef!
  candidates: [UserRef!]
  participants: [VoteRef!]
  comments: [CommentRef!]
}

type AddContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input AddEventFragmentInput {
  event_type: TensionEvent!
  old: String
  new: String
}

type AddEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input AddEventInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  tension: TensionRef!
  event_type: TensionEvent!
  old: String
  new: String
}

type AddEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input AddLabelInput {
  rootnameid: String!
  name: String!
  description: String
  color: String
  tensions: [TensionRef!]
  nodes: [NodeRef!]
  n_nodes: Int
  n_tensions: Int
}

type AddLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input AddMandateInput {
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type AddMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input AddNodeCharacInput {
  userCanJoin: Boolean!
  mode: NodeMode!
}

type AddNodeCharacPayload {
  nodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  numUids: Int
}

input AddNodeFragmentInput {
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharacRef
  about: String
  mandate: MandateRef
  children: [NodeFragmentRef!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

type AddNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input AddNodeInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  nameid: String!
  rootnameid: String!
  parent: NodeRef
  children: [NodeRef!]
  type_: NodeType!
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  about: String
  mandate: MandateRef
  docs: [BlobRef]
  source: BlobRef
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats: NodeStatsRef
  isRoot: Boolean!
  isPersonal: Boolean
  isPrivate: Boolean!
  isArchived: Boolean!
  charac: NodeCharacRef!
  rights: Int!
  labels: [LabelRef!]
  first_link: UserRef
  second_link: UserRef
  skills: [String!]
  role_type: RoleType
  contracts: [VoteRef!]
  shared: SharedNodeRef
}

type AddNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input AddNodeStatsInput {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

type AddNodeStatsPayload {
  nodeStats(filter: NodeStatsFilter, order: NodeStatsOrder, first: Int, offset: Int): [NodeStats]
  numUids: Int
}

input AddSharedNodeInput {
  n_labels: Int
  n_tensions: Int
  n_closed_tensions: Int
}

type AddSharedNodePayload {
  sharedNode(filter: SharedNodeFilter, order: SharedNodeOrder, first: Int, offset: Int): [SharedNode]
  numUids: Int
}

input AddTensionInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  emitterid: String!
  emitter: NodeRef!
  receiverid: String!
  receiver: NodeRef!
  nth: String
  title: String!
  type_: TensionType!
  status: TensionStatus!
  assignees: [UserRef!]
  labels: [LabelRef!]
  comments: [CommentRef!]
  action: TensionAction
  blobs: [BlobRef!]
  contracts: [ContractRef!]
  history: [EventRef!]!
  n_comments: Int
  n_blobs: Int
}

type AddTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input AddUserInput {
  createdAt: DateTime!
  lastAck: DateTime!
  username: String!
  name: String
  password: String!
  email: String!
  emailHash: String
  emailValidated: Boolean!
  rights: UserRightsRef!
  roles: [NodeRef!]
  backed_roles: [NodeRef!]
  tensions_created: [TensionRef!]
  tensions_assigned: [TensionRef!]
  contracts: [ContractRef!]
  bio: String
  utc: String
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AddUserRightsInput {
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  type_: UserType!
}

type AddUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input AddVoteInput {
  contract: ContractRef!
  node: NodeRef!
  data: [Int!]
}

type AddVotePayload {
  vote(filter: VoteFilter, first: Int, offset: Int): [Vote]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Blob implements Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  tension(filter: TensionFilter): Tension!
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node(filter: NodeFragmentFilter): NodeFragment
  md: String
}

type BlobAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  pushedFlagMin: DateTime
  pushedFlagMax: DateTime
  archivedFlagMin: DateTime
  archivedFlagMax: DateTime
  mdMin: String
  mdMax: String
}

input BlobFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  blob_type: BlobType_hash
  pushedFlag: DateTimeFilter
  archivedFlag: DateTimeFilter
  has: [BlobHasFilter]
  and: [BlobFilter]
  or: [BlobFilter]
  not: BlobFilter
}

enum BlobHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  blob_type
  pushedFlag
  archivedFlag
  node
  md
}

input BlobOrder {
  asc: BlobOrderable
  desc: BlobOrderable
  then: BlobOrder
}

enum BlobOrderable {
  createdAt
  updatedAt
  message
  pushedFlag
  archivedFlag
  md
}

input BlobPatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  tension: TensionRef
  blob_type: BlobType
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

input BlobRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  tension: TensionRef
  blob_type: BlobType
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

enum BlobType {
  OnNode
  OnAbout
  OnMandate
  OnFirstLink
  OnDoc
}

input BlobType_hash {
  eq: BlobType
  in: [BlobType]
}

type Comment implements Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  _VOID: String
}

type CommentAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  _VOIDMin: String
  _VOIDMax: String
}

input CommentFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [CommentHasFilter]
  and: [CommentFilter]
  or: [CommentFilter]
  not: CommentFilter
}

enum CommentHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  _VOID
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  createdAt
  updatedAt
  message
  _VOID
}

input CommentPatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  _VOID: String
}

input CommentRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  _VOID: String
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

type Contract implements Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  tension(filter: TensionFilter): Tension!
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event(filter: EventFragmentFilter): EventFragment!
  candidates(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  participants(filter: VoteFilter, first: Int, offset: Int): [Vote!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  candidatesAggregate(filter: UserFilter): UserAggregateResult
  participantsAggregate(filter: VoteFilter): VoteAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
}

type ContractAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  closedAtMin: DateTime
  closedAtMax: DateTime
}

input ContractFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  status: ContractStatus_hash
  contract_type: ContractType_hash
  closedAt: DateTimeFilter
  has: [ContractHasFilter]
  and: [ContractFilter]
  or: [ContractFilter]
  not: ContractFilter
}

enum ContractHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  status
  contract_type
  closedAt
  event
  candidates
  participants
  comments
}

input ContractOrder {
  asc: ContractOrderable
  desc: ContractOrderable
  then: ContractOrder
}

enum ContractOrderable {
  createdAt
  updatedAt
  message
  closedAt
}

input ContractPatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  tension: TensionRef
  status: ContractStatus
  contract_type: ContractType
  closedAt: DateTime
  event: EventFragmentRef
  candidates: [UserRef!]
  participants: [VoteRef!]
  comments: [CommentRef!]
}

input ContractRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  tension: TensionRef
  status: ContractStatus
  contract_type: ContractType
  closedAt: DateTime
  event: EventFragmentRef
  candidates: [UserRef!]
  participants: [VoteRef!]
  comments: [CommentRef!]
}

enum ContractStatus {
  Open
  Closed
  Canceled
}

input ContractStatus_hash {
  eq: ContractStatus
  in: [ContractStatus]
}

enum ContractType {
  AnyCoordoDual
  AnyParticipants
  AnyCoordoSource
  AnyCoordoTarget
}

input ContractType_hash {
  eq: ContractType
  in: [ContractType]
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds
after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  msg: String
  numUids: Int
}

type DeleteCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  msg: String
  numUids: Int
}

type DeleteContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  msg: String
  numUids: Int
}

type DeleteEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  msg: String
  numUids: Int
}

type DeleteEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  msg: String
  numUids: Int
}

type DeleteLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  msg: String
  numUids: Int
}

type DeleteMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  msg: String
  numUids: Int
}

type DeleteNodeCharacPayload {
  nodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  msg: String
  numUids: Int
}

type DeleteNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  msg: String
  numUids: Int
}

type DeleteNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  msg: String
  numUids: Int
}

type DeleteNodeStatsPayload {
  nodeStats(filter: NodeStatsFilter, order: NodeStatsOrder, first: Int, offset: Int): [NodeStats]
  msg: String
  numUids: Int
}

type DeletePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  msg: String
  numUids: Int
}

type DeleteSharedNodePayload {
  sharedNode(filter: SharedNodeFilter, order: SharedNodeOrder, first: Int, offset: Int): [SharedNode]
  msg: String
  numUids: Int
}

type DeleteTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

type DeleteUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  msg: String
  numUids: Int
}

type DeleteVotePayload {
  vote(filter: VoteFilter, first: Int, offset: Int): [Vote]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

type Event implements Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  tension(filter: TensionFilter): Tension!
  event_type: TensionEvent!
  old: String
  new: String
}

type EventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

input EventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  event_type: TensionEvent_hash
  has: [EventHasFilter]
  and: [EventFilter]
  or: [EventFilter]
  not: EventFilter
}

type EventFragment {
  event_type: TensionEvent!
  old: String
  new: String
}

type EventFragmentAggregateResult {
  count: Int
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

input EventFragmentFilter {
  event_type: TensionEvent_hash
  has: [EventFragmentHasFilter]
  and: [EventFragmentFilter]
  or: [EventFragmentFilter]
  not: EventFragmentFilter
}

enum EventFragmentHasFilter {
  event_type
  old
  new
}

input EventFragmentOrder {
  asc: EventFragmentOrderable
  desc: EventFragmentOrderable
  then: EventFragmentOrder
}

enum EventFragmentOrderable {
  old
  new
}

input EventFragmentPatch {
  event_type: TensionEvent
  old: String
  new: String
}

input EventFragmentRef {
  event_type: TensionEvent
  old: String
  new: String
}

enum EventHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  event_type
  old
  new
}

input EventOrder {
  asc: EventOrderable
  desc: EventOrderable
  then: EventOrder
}

enum EventOrderable {
  createdAt
  updatedAt
  message
  old
  new
}

input EventPatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  tension: TensionRef
  event_type: TensionEvent
  old: String
  new: String
}

input EventRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  tension: TensionRef
  event_type: TensionEvent
  old: String
  new: String
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type Label {
  id: ID!
  rootnameid: String!
  name: String!
  description: String
  color: String
  tensions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  n_nodes: Int
  n_tensions: Int
  tensionsAggregate(filter: TensionFilter): TensionAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type LabelAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  colorMin: String
  colorMax: String
  n_nodesMin: Int
  n_nodesMax: Int
  n_nodesSum: Int
  n_nodesAvg: Float
  n_tensionsMin: Int
  n_tensionsMax: Int
  n_tensionsSum: Int
  n_tensionsAvg: Float
}

input LabelFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter
  has: [LabelHasFilter]
  and: [LabelFilter]
  or: [LabelFilter]
  not: LabelFilter
}

enum LabelHasFilter {
  rootnameid
  name
  description
  color
  tensions
  nodes
  n_nodes
  n_tensions
}

input LabelOrder {
  asc: LabelOrderable
  desc: LabelOrderable
  then: LabelOrder
}

enum LabelOrderable {
  rootnameid
  name
  description
  color
  n_nodes
  n_tensions
}

input LabelPatch {
  rootnameid: String
  name: String
  description: String
  color: String
  tensions: [TensionRef!]
  nodes: [NodeRef!]
  n_nodes: Int
  n_tensions: Int
}

input LabelRef {
  id: ID
  rootnameid: String
  name: String
  description: String
  color: String
  tensions: [TensionRef!]
  nodes: [NodeRef!]
  n_nodes: Int
  n_tensions: Int
}

type Mandate {
  id: ID!
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type MandateAggregateResult {
  count: Int
  purposeMin: String
  purposeMax: String
  responsabilitiesMin: String
  responsabilitiesMax: String
  domainsMin: String
  domainsMax: String
  policiesMin: String
  policiesMax: String
}

input MandateFilter {
  id: [ID!]
  purpose: StringFullTextFilter
  has: [MandateHasFilter]
  and: [MandateFilter]
  or: [MandateFilter]
  not: MandateFilter
}

enum MandateHasFilter {
  purpose
  responsabilities
  domains
  policies
}

input MandateOrder {
  asc: MandateOrderable
  desc: MandateOrderable
  then: MandateOrder
}

enum MandateOrderable {
  purpose
  responsabilities
  domains
  policies
}

input MandatePatch {
  purpose: String
  responsabilities: String
  domains: String
  policies: String
}

input MandateRef {
  id: ID
  purpose: String
  responsabilities: String
  domains: String
  policies: String
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addNode(input: [AddNodeInput!]!, upsert: Boolean): AddNodePayload
  updateNode(input: UpdateNodeInput!): UpdateNodePayload
  deleteNode(filter: NodeFilter!): DeleteNodePayload
  addSharedNode(input: [AddSharedNodeInput!]!): AddSharedNodePayload
  updateSharedNode(input: UpdateSharedNodeInput!): UpdateSharedNodePayload
  deleteSharedNode(filter: SharedNodeFilter!): DeleteSharedNodePayload
  addNodeFragment(input: [AddNodeFragmentInput!]!): AddNodeFragmentPayload
  updateNodeFragment(input: UpdateNodeFragmentInput!): UpdateNodeFragmentPayload
  deleteNodeFragment(filter: NodeFragmentFilter!): DeleteNodeFragmentPayload
  addMandate(input: [AddMandateInput!]!): AddMandatePayload
  updateMandate(input: UpdateMandateInput!): UpdateMandatePayload
  deleteMandate(filter: MandateFilter!): DeleteMandatePayload
  addNodeCharac(input: [AddNodeCharacInput!]!): AddNodeCharacPayload
  updateNodeCharac(input: UpdateNodeCharacInput!): UpdateNodeCharacPayload
  deleteNodeCharac(filter: NodeCharacFilter!): DeleteNodeCharacPayload
  addNodeStats(input: [AddNodeStatsInput!]!): AddNodeStatsPayload
  updateNodeStats(input: UpdateNodeStatsInput!): UpdateNodeStatsPayload
  deleteNodeStats(filter: NodeStatsFilter!): DeleteNodeStatsPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  deletePost(filter: PostFilter!): DeletePostPayload
  addTension(input: [AddTensionInput!]!): AddTensionPayload
  updateTension(input: UpdateTensionInput!): UpdateTensionPayload
  deleteTension(filter: TensionFilter!): DeleteTensionPayload
  addLabel(input: [AddLabelInput!]!): AddLabelPayload
  updateLabel(input: UpdateLabelInput!): UpdateLabelPayload
  deleteLabel(filter: LabelFilter!): DeleteLabelPayload
  addComment(input: [AddCommentInput!]!): AddCommentPayload
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload
  deleteComment(filter: CommentFilter!): DeleteCommentPayload
  addBlob(input: [AddBlobInput!]!): AddBlobPayload
  updateBlob(input: UpdateBlobInput!): UpdateBlobPayload
  deleteBlob(filter: BlobFilter!): DeleteBlobPayload
  addEvent(input: [AddEventInput!]!): AddEventPayload
  updateEvent(input: UpdateEventInput!): UpdateEventPayload
  deleteEvent(filter: EventFilter!): DeleteEventPayload
  addEventFragment(input: [AddEventFragmentInput!]!): AddEventFragmentPayload
  updateEventFragment(input: UpdateEventFragmentInput!): UpdateEventFragmentPayload
  deleteEventFragment(filter: EventFragmentFilter!): DeleteEventFragmentPayload
  addContract(input: [AddContractInput!]!): AddContractPayload
  updateContract(input: UpdateContractInput!): UpdateContractPayload
  deleteContract(filter: ContractFilter!): DeleteContractPayload
  addVote(input: [AddVoteInput!]!): AddVotePayload
  updateVote(input: UpdateVoteInput!): UpdateVotePayload
  deleteVote(filter: VoteFilter!): DeleteVotePayload
  addUser(input: [AddUserInput!]!, upsert: Boolean): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addUserRights(input: [AddUserRightsInput!]!): AddUserRightsPayload
  updateUserRights(input: UpdateUserRightsInput!): UpdateUserRightsPayload
  deleteUserRights(filter: UserRightsFilter!): DeleteUserRightsPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Node {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  name: String!
  nameid: String!
  rootnameid: String!
  parent(filter: NodeFilter): Node
  children(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  type_: NodeType!
  tensions_out(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  tensions_in(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  about: String
  mandate(filter: MandateFilter): Mandate
  docs(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  source(filter: BlobFilter): Blob
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats(filter: NodeStatsFilter): NodeStats
  isRoot: Boolean!
  isPersonal: Boolean
  isPrivate: Boolean!
  isArchived: Boolean!
  charac(filter: NodeCharacFilter): NodeCharac!
  rights: Int!
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  first_link(filter: UserFilter): User
  second_link(filter: UserFilter): User
  skills: [String!]
  role_type: RoleType
  contracts(filter: VoteFilter, first: Int, offset: Int): [Vote!]
  shared(filter: SharedNodeFilter): SharedNode
  childrenAggregate(filter: NodeFilter): NodeAggregateResult
  tensions_outAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_inAggregate(filter: TensionFilter): TensionAggregateResult
  docsAggregate(filter: BlobFilter): BlobAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  contractsAggregate(filter: VoteFilter): VoteAggregateResult
}

type NodeAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  nameMin: String
  nameMax: String
  nameidMin: String
  nameidMax: String
  rootnameidMin: String
  rootnameidMax: String
  aboutMin: String
  aboutMax: String
  n_tensions_outMin: Int
  n_tensions_outMax: Int
  n_tensions_outSum: Int
  n_tensions_outAvg: Float
  n_tensions_inMin: Int
  n_tensions_inMax: Int
  n_tensions_inSum: Int
  n_tensions_inAvg: Float
  n_childrenMin: Int
  n_childrenMax: Int
  n_childrenSum: Int
  n_childrenAvg: Float
  rightsMin: Int
  rightsMax: Int
  rightsSum: Int
  rightsAvg: Float
}

type NodeCharac {
  id: ID!
  userCanJoin: Boolean!
  mode: NodeMode!
}

type NodeCharacAggregateResult {
  count: Int
}

input NodeCharacFilter {
  id: [ID!]
  userCanJoin: Boolean
  mode: NodeMode_hash
  has: [NodeCharacHasFilter]
  and: [NodeCharacFilter]
  or: [NodeCharacFilter]
  not: NodeCharacFilter
}

enum NodeCharacHasFilter {
  userCanJoin
  mode
}

input NodeCharacPatch {
  userCanJoin: Boolean
  mode: NodeMode
}

input NodeCharacRef {
  id: ID
  userCanJoin: Boolean
  mode: NodeMode
}

input NodeFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  name: StringTermFilter
  nameid: StringHashFilter_StringRegExpFilter
  rootnameid: StringHashFilter_StringRegExpFilter
  type_: NodeType_hash
  about: StringFullTextFilter
  isRoot: Boolean
  isPersonal: Boolean
  isPrivate: Boolean
  isArchived: Boolean
  skills: StringTermFilter
  role_type: RoleType_hash
  has: [NodeHasFilter]
  and: [NodeFilter]
  or: [NodeFilter]
  not: NodeFilter
}

type NodeFragment {
  id: ID!
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac(filter: NodeCharacFilter): NodeCharac
  about: String
  mandate(filter: MandateFilter): Mandate
  children(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
  childrenAggregate(filter: NodeFragmentFilter): NodeFragmentAggregateResult
}

type NodeFragmentAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  nameidMin: String
  nameidMax: String
  aboutMin: String
  aboutMax: String
  first_linkMin: String
  first_linkMax: String
  second_linkMin: String
  second_linkMax: String
}

input NodeFragmentFilter {
  id: [ID!]
  has: [NodeFragmentHasFilter]
  and: [NodeFragmentFilter]
  or: [NodeFragmentFilter]
  not: NodeFragmentFilter
}

enum NodeFragmentHasFilter {
  name
  nameid
  type_
  isPrivate
  charac
  about
  mandate
  children
  first_link
  second_link
  skills
  role_type
}

input NodeFragmentOrder {
  asc: NodeFragmentOrderable
  desc: NodeFragmentOrderable
  then: NodeFragmentOrder
}

enum NodeFragmentOrderable {
  name
  nameid
  about
  first_link
  second_link
}

input NodeFragmentPatch {
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharacRef
  about: String
  mandate: MandateRef
  children: [NodeFragmentRef!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

input NodeFragmentRef {
  id: ID
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharacRef
  about: String
  mandate: MandateRef
  children: [NodeFragmentRef!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

enum NodeHasFilter {
  createdBy
  createdAt
  updatedAt
  name
  nameid
  rootnameid
  parent
  children
  type_
  tensions_out
  tensions_in
  about
  mandate
  docs
  source
  n_tensions_out
  n_tensions_in
  n_children
  stats
  isRoot
  isPersonal
  isPrivate
  isArchived
  charac
  rights
  labels
  first_link
  second_link
  skills
  role_type
  contracts
  shared
}

enum NodeMode {
  Coordinated
  Agile
}

input NodeMode_hash {
  eq: NodeMode
  in: [NodeMode]
}

input NodeOrder {
  asc: NodeOrderable
  desc: NodeOrderable
  then: NodeOrder
}

enum NodeOrderable {
  createdAt
  updatedAt
  name
  nameid
  rootnameid
  about
  n_tensions_out
  n_tensions_in
  n_children
  rights
}

input NodePatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  rootnameid: String
  parent: NodeRef
  children: [NodeRef!]
  type_: NodeType
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  about: String
  mandate: MandateRef
  docs: [BlobRef]
  source: BlobRef
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats: NodeStatsRef
  isRoot: Boolean
  isPersonal: Boolean
  isPrivate: Boolean
  isArchived: Boolean
  charac: NodeCharacRef
  rights: Int
  labels: [LabelRef!]
  first_link: UserRef
  second_link: UserRef
  skills: [String!]
  role_type: RoleType
  contracts: [VoteRef!]
  shared: SharedNodeRef
}

input NodeRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  nameid: String
  rootnameid: String
  parent: NodeRef
  children: [NodeRef!]
  type_: NodeType
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  about: String
  mandate: MandateRef
  docs: [BlobRef]
  source: BlobRef
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats: NodeStatsRef
  isRoot: Boolean
  isPersonal: Boolean
  isPrivate: Boolean
  isArchived: Boolean
  charac: NodeCharacRef
  rights: Int
  labels: [LabelRef!]
  first_link: UserRef
  second_link: UserRef
  skills: [String!]
  role_type: RoleType
  contracts: [VoteRef!]
  shared: SharedNodeRef
}

type NodeStats {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

type NodeStatsAggregateResult {
  count: Int
  n_memberMin: Int
  n_memberMax: Int
  n_memberSum: Int
  n_memberAvg: Float
  n_guestMin: Int
  n_guestMax: Int
  n_guestSum: Int
  n_guestAvg: Float
  n_circleMin: Int
  n_circleMax: Int
  n_circleSum: Int
  n_circleAvg: Float
  n_roleMin: Int
  n_roleMax: Int
  n_roleSum: Int
  n_roleAvg: Float
}

input NodeStatsFilter {
  has: [NodeStatsHasFilter]
  and: [NodeStatsFilter]
  or: [NodeStatsFilter]
  not: NodeStatsFilter
}

enum NodeStatsHasFilter {
  n_member
  n_guest
  n_circle
  n_role
}

input NodeStatsOrder {
  asc: NodeStatsOrderable
  desc: NodeStatsOrderable
  then: NodeStatsOrder
}

enum NodeStatsOrderable {
  n_member
  n_guest
  n_circle
  n_role
}

input NodeStatsPatch {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

input NodeStatsRef {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

enum NodeType {
  Circle
  Role
}

input NodeType_hash {
  eq: NodeType
  in: [NodeType]
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

interface Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type PostAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input PostFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [PostHasFilter]
  and: [PostFilter]
  or: [PostFilter]
  not: PostFilter
}

enum PostHasFilter {
  createdBy
  createdAt
  updatedAt
  message
}

input PostOrder {
  asc: PostOrderable
  desc: PostOrderable
  then: PostOrder
}

enum PostOrderable {
  createdAt
  updatedAt
  message
}

input PostPatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
}

input PostRef {
  id: ID!
}

type Query {
  getNode(id: ID, nameid: String): Node
  queryNode(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  aggregateNode(filter: NodeFilter): NodeAggregateResult
  querySharedNode(filter: SharedNodeFilter, order: SharedNodeOrder, first: Int, offset: Int): [SharedNode]
  aggregateSharedNode(filter: SharedNodeFilter): SharedNodeAggregateResult
  getNodeFragment(id: ID!): NodeFragment
  queryNodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  aggregateNodeFragment(filter: NodeFragmentFilter): NodeFragmentAggregateResult
  getMandate(id: ID!): Mandate
  queryMandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  aggregateMandate(filter: MandateFilter): MandateAggregateResult
  getNodeCharac(id: ID!): NodeCharac
  queryNodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  aggregateNodeCharac(filter: NodeCharacFilter): NodeCharacAggregateResult
  queryNodeStats(filter: NodeStatsFilter, order: NodeStatsOrder, first: Int, offset: Int): [NodeStats]
  aggregateNodeStats(filter: NodeStatsFilter): NodeStatsAggregateResult
  getPost(id: ID!): Post
  queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  aggregatePost(filter: PostFilter): PostAggregateResult
  getTension(id: ID!): Tension
  queryTension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  aggregateTension(filter: TensionFilter): TensionAggregateResult
  getLabel(id: ID!): Label
  queryLabel(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  aggregateLabel(filter: LabelFilter): LabelAggregateResult
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  aggregateComment(filter: CommentFilter): CommentAggregateResult
  getBlob(id: ID!): Blob
  queryBlob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  aggregateBlob(filter: BlobFilter): BlobAggregateResult
  getEvent(id: ID!): Event
  queryEvent(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  aggregateEvent(filter: EventFilter): EventAggregateResult
  queryEventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  aggregateEventFragment(filter: EventFragmentFilter): EventFragmentAggregateResult
  getContract(id: ID!): Contract
  queryContract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  aggregateContract(filter: ContractFilter): ContractAggregateResult
  getVote(id: ID!): Vote
  queryVote(filter: VoteFilter, first: Int, offset: Int): [Vote]
  aggregateVote(filter: VoteFilter): VoteAggregateResult
  getUser(id: ID, username: String): User
  queryUser(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  queryUserRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  aggregateUserRights(filter: UserRightsFilter): UserRightsAggregateResult
}

enum RoleType {
  Owner
  Member
  Guest
  Retired
  Pending
  Coordinator
  Peer
  Bot
}

input RoleType_hash {
  eq: RoleType
  in: [RoleType]
}

type SharedNode {
  n_labels: Int
  n_tensions: Int
  n_closed_tensions: Int
}

type SharedNodeAggregateResult {
  count: Int
  n_labelsMin: Int
  n_labelsMax: Int
  n_labelsSum: Int
  n_labelsAvg: Float
  n_tensionsMin: Int
  n_tensionsMax: Int
  n_tensionsSum: Int
  n_tensionsAvg: Float
  n_closed_tensionsMin: Int
  n_closed_tensionsMax: Int
  n_closed_tensionsSum: Int
  n_closed_tensionsAvg: Float
}

input SharedNodeFilter {
  has: [SharedNodeHasFilter]
  and: [SharedNodeFilter]
  or: [SharedNodeFilter]
  not: SharedNodeFilter
}

enum SharedNodeHasFilter {
  n_labels
  n_tensions
  n_closed_tensions
}

input SharedNodeOrder {
  asc: SharedNodeOrderable
  desc: SharedNodeOrderable
  then: SharedNodeOrder
}

enum SharedNodeOrderable {
  n_labels
  n_tensions
  n_closed_tensions
}

input SharedNodePatch {
  n_labels: Int
  n_tensions: Int
  n_closed_tensions: Int
}

input SharedNodeRef {
  n_labels: Int
  n_tensions: Int
  n_closed_tensions: Int
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringHashFilter_StringTermFilter {
  eq: String
  in: [String]
  allofterms: String
  anyofterms: String
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Tension implements Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
  emitterid: String!
  emitter(filter: NodeFilter): Node!
  receiverid: String!
  receiver(filter: NodeFilter): Node!
  nth: String
  title: String!
  type_: TensionType!
  status: TensionStatus!
  assignees(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  action: TensionAction
  blobs(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob!]
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]!
  n_comments: Int
  n_blobs: Int
  assigneesAggregate(filter: UserFilter): UserAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
  blobsAggregate(filter: BlobFilter): BlobAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  historyAggregate(filter: EventFilter): EventAggregateResult
}

enum TensionAction {
  NewRole
  NewCircle
  NewMd
  EditRole
  EditCircle
  EditMd
  ArchivedRole
  ArchivedCircle
  ArchivedMd
}

type TensionAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  emitteridMin: String
  emitteridMax: String
  receiveridMin: String
  receiveridMax: String
  nthMin: String
  nthMax: String
  titleMin: String
  titleMax: String
  n_commentsMin: Int
  n_commentsMax: Int
  n_commentsSum: Int
  n_commentsAvg: Float
  n_blobsMin: Int
  n_blobsMax: Int
  n_blobsSum: Int
  n_blobsAvg: Float
}

enum TensionEvent {
  Created
  Reopened
  Closed
  TitleUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  BlobCreated
  BlobCommitted
  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoined
  UserLeft
  Moved
}

input TensionEvent_hash {
  eq: TensionEvent
  in: [TensionEvent]
}

input TensionFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  emitterid: StringHashFilter_StringRegExpFilter
  receiverid: StringHashFilter_StringRegExpFilter
  nth: StringTermFilter
  title: StringFullTextFilter
  type_: TensionType_hash
  status: TensionStatus_hash
  has: [TensionHasFilter]
  and: [TensionFilter]
  or: [TensionFilter]
  not: TensionFilter
}

enum TensionHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  emitterid
  emitter
  receiverid
  receiver
  nth
  title
  type_
  status
  assignees
  labels
  comments
  action
  blobs
  contracts
  history
  n_comments
  n_blobs
}

input TensionOrder {
  asc: TensionOrderable
  desc: TensionOrderable
  then: TensionOrder
}

enum TensionOrderable {
  createdAt
  updatedAt
  message
  emitterid
  receiverid
  nth
  title
  n_comments
  n_blobs
}

input TensionPatch {
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  emitterid: String
  emitter: NodeRef
  receiverid: String
  receiver: NodeRef
  nth: String
  title: String
  type_: TensionType
  status: TensionStatus
  assignees: [UserRef!]
  labels: [LabelRef!]
  comments: [CommentRef!]
  action: TensionAction
  blobs: [BlobRef!]
  contracts: [ContractRef!]
  history: [EventRef!]
  n_comments: Int
  n_blobs: Int
}

input TensionRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  message: String
  emitterid: String
  emitter: NodeRef
  receiverid: String
  receiver: NodeRef
  nth: String
  title: String
  type_: TensionType
  status: TensionStatus
  assignees: [UserRef!]
  labels: [LabelRef!]
  comments: [CommentRef!]
  action: TensionAction
  blobs: [BlobRef!]
  contracts: [ContractRef!]
  history: [EventRef!]
  n_comments: Int
  n_blobs: Int
}

enum TensionStatus {
  Open
  Closed
}

input TensionStatus_hash {
  eq: TensionStatus
  in: [TensionStatus]
}

enum TensionType {
  Operational
  Governance
  Help
}

input TensionType_hash {
  eq: TensionType
  in: [TensionType]
}

input UpdateBlobInput {
  filter: BlobFilter!
  set: BlobPatch
  remove: BlobPatch
}

type UpdateBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input UpdateContractInput {
  filter: ContractFilter!
  set: ContractPatch
  remove: ContractPatch
}

type UpdateContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input UpdateEventFragmentInput {
  filter: EventFragmentFilter!
  set: EventFragmentPatch
  remove: EventFragmentPatch
}

type UpdateEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input UpdateEventInput {
  filter: EventFilter!
  set: EventPatch
  remove: EventPatch
}

type UpdateEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input UpdateLabelInput {
  filter: LabelFilter!
  set: LabelPatch
  remove: LabelPatch
}

type UpdateLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input UpdateMandateInput {
  filter: MandateFilter!
  set: MandatePatch
  remove: MandatePatch
}

type UpdateMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input UpdateNodeCharacInput {
  filter: NodeCharacFilter!
  set: NodeCharacPatch
  remove: NodeCharacPatch
}

type UpdateNodeCharacPayload {
  nodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  numUids: Int
}

input UpdateNodeFragmentInput {
  filter: NodeFragmentFilter!
  set: NodeFragmentPatch
  remove: NodeFragmentPatch
}

type UpdateNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input UpdateNodeInput {
  filter: NodeFilter!
  set: NodePatch
  remove: NodePatch
}

type UpdateNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input UpdateNodeStatsInput {
  filter: NodeStatsFilter!
  set: NodeStatsPatch
  remove: NodeStatsPatch
}

type UpdateNodeStatsPayload {
  nodeStats(filter: NodeStatsFilter, order: NodeStatsOrder, first: Int, offset: Int): [NodeStats]
  numUids: Int
}

input UpdatePostInput {
  filter: PostFilter!
  set: PostPatch
  remove: PostPatch
}

type UpdatePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  numUids: Int
}

input UpdateSharedNodeInput {
  filter: SharedNodeFilter!
  set: SharedNodePatch
  remove: SharedNodePatch
}

type UpdateSharedNodePayload {
  sharedNode(filter: SharedNodeFilter, order: SharedNodeOrder, first: Int, offset: Int): [SharedNode]
  numUids: Int
}

input UpdateTensionInput {
  filter: TensionFilter!
  set: TensionPatch
  remove: TensionPatch
}

type UpdateTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UpdateUserRightsInput {
  filter: UserRightsFilter!
  set: UserRightsPatch
  remove: UserRightsPatch
}

type UpdateUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input UpdateVoteInput {
  filter: VoteFilter!
  set: VotePatch
  remove: VotePatch
}

type UpdateVotePayload {
  vote(filter: VoteFilter, first: Int, offset: Int): [Vote]
  numUids: Int
}

type User {
  id: ID!
  createdAt: DateTime!
  lastAck: DateTime!
  username: String!
  name: String
  password: String!
  email: String!
  emailHash: String
  emailValidated: Boolean!
  rights(filter: UserRightsFilter): UserRights!
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  backed_roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  tensions_created(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  tensions_assigned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  bio: String
  utc: String
  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  backed_rolesAggregate(filter: NodeFilter): NodeAggregateResult
  tensions_createdAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_assignedAggregate(filter: TensionFilter): TensionAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
}

type UserAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  lastAckMin: DateTime
  lastAckMax: DateTime
  usernameMin: String
  usernameMax: String
  nameMin: String
  nameMax: String
  passwordMin: String
  passwordMax: String
  emailMin: String
  emailMax: String
  emailHashMin: String
  emailHashMax: String
  bioMin: String
  bioMax: String
  utcMin: String
  utcMax: String
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter
  email: StringHashFilter
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

enum UserHasFilter {
  createdAt
  lastAck
  username
  name
  password
  email
  emailHash
  emailValidated
  rights
  roles
  backed_roles
  tensions_created
  tensions_assigned
  contracts
  bio
  utc
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  createdAt
  lastAck
  username
  name
  password
  email
  emailHash
  bio
  utc
}

input UserPatch {
  createdAt: DateTime
  lastAck: DateTime
  name: String
  password: String
  email: String
  emailHash: String
  emailValidated: Boolean
  rights: UserRightsRef
  roles: [NodeRef!]
  backed_roles: [NodeRef!]
  tensions_created: [TensionRef!]
  tensions_assigned: [TensionRef!]
  contracts: [ContractRef!]
  bio: String
  utc: String
}

input UserRef {
  id: ID
  createdAt: DateTime
  lastAck: DateTime
  username: String
  name: String
  password: String
  email: String
  emailHash: String
  emailValidated: Boolean
  rights: UserRightsRef
  roles: [NodeRef!]
  backed_roles: [NodeRef!]
  tensions_created: [TensionRef!]
  tensions_assigned: [TensionRef!]
  contracts: [ContractRef!]
  bio: String
  utc: String
}

type UserRights {
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  type_: UserType!
}

type UserRightsAggregateResult {
  count: Int
  maxPublicOrgaMin: Int
  maxPublicOrgaMax: Int
  maxPublicOrgaSum: Int
  maxPublicOrgaAvg: Float
}

input UserRightsFilter {
  has: [UserRightsHasFilter]
  and: [UserRightsFilter]
  or: [UserRightsFilter]
  not: UserRightsFilter
}

enum UserRightsHasFilter {
  canLogin
  canCreateRoot
  maxPublicOrga
  type_
}

input UserRightsOrder {
  asc: UserRightsOrderable
  desc: UserRightsOrderable
  then: UserRightsOrder
}

enum UserRightsOrderable {
  maxPublicOrga
}

input UserRightsPatch {
  canLogin: Boolean
  canCreateRoot: Boolean
  maxPublicOrga: Int
  type_: UserType
}

input UserRightsRef {
  canLogin: Boolean
  canCreateRoot: Boolean
  maxPublicOrga: Int
  type_: UserType
}

enum UserType {
  Regular
  Root
}

type Vote {
  id: ID!
  contract(filter: ContractFilter): Contract!
  node(filter: NodeFilter): Node!
  data: [Int!]
}

type VoteAggregateResult {
  count: Int
}

input VoteFilter {
  id: [ID!]
  has: [VoteHasFilter]
  and: [VoteFilter]
  or: [VoteFilter]
  not: VoteFilter
}

enum VoteHasFilter {
  contract
  node
  data
}

input VotePatch {
  contract: ContractRef
  node: NodeRef
  data: [Int!]
}

input VoteRef {
  id: ID
  contract: ContractRef
  node: NodeRef
  data: [Int!]
}

input WithinFilter {
  polygon: PolygonRef!
}

