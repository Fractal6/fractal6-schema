


directive @hidden on FIELD_DEFINITION

directive @count(f: String!) on FIELD_DEFINITION

directive @meta_getNodeStats on FIELD_DEFINITION

directive @hook_addNode on ARGUMENT_DEFINITION

directive @hook_addNodePost on FIELD_DEFINITION

directive @hook_updateNode on ARGUMENT_DEFINITION

directive @hook_updateNodePost on FIELD_DEFINITION

directive @hook_addTension on ARGUMENT_DEFINITION

directive @hook_addTensionPost on FIELD_DEFINITION

directive @hook_updateTension on ARGUMENT_DEFINITION

directive @hook_updateTensionPost on FIELD_DEFINITION

directive @hook_updateComment on ARGUMENT_DEFINITION

directive @hook_updateCommentPost on FIELD_DEFINITION

directive @alter_toLower(f: String!) on INPUT_FIELD_DEFINITION

directive @alter_maxLength(f: String!, n: Int!) on INPUT_FIELD_DEFINITION

directive @alter_assertType(f: String!, t: NodeType!) on INPUT_FIELD_DEFINITION

directive @hidePrivate on OBJECT|FIELD_DEFINITION

directive @isAuth on OBJECT|FIELD_DEFINITION

directive @patch_hasRole(n: [String!]!, r: RoleType!, u: String) on INPUT_FIELD_DEFINITION

directive @alter_hasRole(n: [String!]!, r: RoleType!, u: String) on INPUT_FIELD_DEFINITION

directive @alter_hasRoot(n: [String!]!) on INPUT_FIELD_DEFINITION

directive @add_isOwner(u: String) on INPUT_FIELD_DEFINITION

directive @patch_isOwner(u: String) on INPUT_FIELD_DEFINITION

directive @patch_RO on INPUT_FIELD_DEFINITION

directive @alter_RO on INPUT_FIELD_DEFINITION

type Node @hidePrivate {
  id: ID!
  createdAt: DateTime! @search
  createdBy(filter: UserFilter): User!
  name: String! @search(by: [term])
  nameid: String! @id @search(by: [hash, regexp])
  rootnameid: String! @search(by: [hash, regexp])
  parent(filter: NodeFilter): Node
  children(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!] @hasInverse(field: parent)
  type_: NodeType! @search
  tensions_out(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @hasInverse(field: emitter)
  tensions_in(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @hasInverse(field: receiver)
  about: String @search(by: [fulltext])
  mandate(filter: MandateFilter): Mandate
  docs(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  source(filter: TensionFilter): Tension
  n_tensions_out: Int @count(f: tensions_out)
  n_tensions_in: Int @count(f: tensions_in)
  n_children: Int @count(f: children)
  stats: NodeStats @meta_getNodeStats
  isRoot: Boolean! @search
  isPrivate: Boolean! @search
  isArchived: Boolean! @search
  charac(filter: NodeCharacFilter): NodeCharac!
  first_link(filter: UserFilter): User
  second_link(filter: UserFilter): User
  skills: [String!] @search(by: [term])
  role_type: RoleType @search
}

type NodeFragment {
  id: ID!
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac(filter: NodeCharacFilter): NodeCharac
  about: String
  mandate(filter: MandateFilter): Mandate
  children(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

type NodeCharac {
  id: ID!
  mode: NodeMode! @search
  userCanJoin: Boolean! @search
}

type NodeStats {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

type Post {
  id: ID!
  createdAt: DateTime! @search
  updatedAt: DateTime
  createdBy(filter: UserFilter): User!
  message: String @search(by: [fulltext])
}

type Tension {
  createdBy(filter: UserFilter): User!
  nth: String @search
  title: String! @search(by: [fulltext])
  type_: TensionType! @search
  emitterid: String! @search(by: [hash, regexp])
  emitter(filter: NodeFilter): Node!
  receiverid: String! @search(by: [hash, regexp])
  receiver(filter: NodeFilter): Node!
  status: TensionStatus! @search
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  assignees(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  action: TensionAction
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  blobs(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob!] @hasInverse(field: tension)
  history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]!
  n_comments: Int @count(f: comments)
  n_blobs: Int @count(f: blobs)
  id: ID!
  createdAt: DateTime! @search
  updatedAt: DateTime
  message: String @search(by: [fulltext])
}

type Label {
  id: ID!
  name: String! @id
  color: String
}

type Comment {
  message: String! @search(by: [fulltext])
  id: ID!
  createdAt: DateTime! @search
  updatedAt: DateTime
  createdBy(filter: UserFilter): User!
}

type Blob {
  tension(filter: TensionFilter): Tension!
  blob_type: BlobType! @search
  pushedFlag: DateTime @search
  archivedFlag: DateTime @search
  node(filter: NodeFragmentFilter): NodeFragment
  md: String
  id: ID!
  createdAt: DateTime! @search
  updatedAt: DateTime
  createdBy(filter: UserFilter): User!
  message: String @search(by: [fulltext])
}

type Event {
  event_type: TensionEvent! @search
  old: String
  new: String
  id: ID!
  createdAt: DateTime! @search
  updatedAt: DateTime
  createdBy(filter: UserFilter): User!
  message: String @search(by: [fulltext])
}

type Mandate {
  id: ID!
  purpose: String! @search(by: [fulltext])
  responsabilities: String
  domains: String
  policies: String
}

type User {
  id: ID!
  createdAt: DateTime!
  username: String! @id
  name: String
  password: String! @hidden
  email: String! @search(by: [hash]) @hidden
  emailHash: String @hidden
  emailValidated: Boolean! @hidden
  rights: UserRights!
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!] @hasInverse(field: first_link)
  backed_roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!] @hasInverse(field: second_link)
  tensions_created(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @hasInverse(field: createdBy)
  tensions_assigned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @hasInverse(field: assignees)
  bio: String
  utc: String
}

type UserRights {
  canLogin: Boolean!
  canCreateRoot: Boolean!
}

enum NodeType {
  Circle
  Role
}

enum RoleType {

  Coordinator
  Peer

  Member

  Guest


}

enum NodeMode {
  Chaos
  Coordinated
}

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Governance
  Operational
  Personal
  Help


}

enum TensionAction {

  NewRole
  NewCircle
  NewMd

  EditRole
  EditCircle
  EditMd

  ArchivedRole
  ArchivedCircle
  ArchivedMd




}

enum TensionEvent {

  Created
  Reopened
  Closed
  TitleUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved





  BlobCreated
  BlobCommitted
  BlobPushed
  BlobArchived
  BlobUnarchived
}

enum BlobType {

  OnNode
  OnAbout
  OnMandate
  OnFirstLink

  OnDoc

}

directive @remote on OBJECT|INTERFACE

directive @cascade on FIELD

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT|INTERFACE|FIELD_DEFINITION

directive @auth(query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT

directive @id on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT|INTERFACE

directive @custom(http: CustomHTTP) on FIELD_DEFINITION

input AddBlobInput {
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: UserRef!
  message: String
  tension: TensionRef!
  blob_type: BlobType!
  pushedFlag: DateTime @alter_RO
  archivedFlag: DateTime @alter_RO
  node: NodeFragmentRef
  md: String
}

type AddBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input AddCommentInput {
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: UserRef!
  message: String
  _VOID: String
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input AddEventInput {
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: UserRef!
  message: String
  event_type: TensionEvent!
  old: String
  new: String
}

type AddEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input AddLabelInput {
  name: String!
  color: String
}

type AddLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input AddMandateInput {
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type AddMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input AddNodeCharacInput {
  mode: NodeMode!
  userCanJoin: Boolean!
}

type AddNodeCharacPayload {
  nodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  numUids: Int
}

input AddNodeFragmentInput {
  name: String
  nameid: String @alter_toLower(f:"nameid")
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharacRef
  about: String @alter_maxLength(f:"about", n:280)
  mandate: MandateRef
  children: [NodeFragmentRef!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

type AddNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input AddNodeInput {
  createdAt: DateTime!
  createdBy: UserRef! @add_isOwner(u:"createdBy")
  name: String!
  nameid: String!
  rootnameid: String!
  parent: NodeRef
  children: [NodeRef!]
  type_: NodeType!
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  about: String
  mandate: MandateRef
  docs: [TensionRef]
  source: TensionRef
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats: NodeStatsRef
  isRoot: Boolean!
  isPrivate: Boolean!
  isArchived: Boolean!
  charac: NodeCharacRef!
  first_link: UserRef
  second_link: UserRef
  skills: [String!]
  role_type: RoleType
}

type AddNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input AddNodeStatsInput {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

type AddNodeStatsPayload {
  nodeStats(order: NodeStatsOrder, first: Int, offset: Int): [NodeStats]
  numUids: Int
}

input AddTensionInput {
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: UserRef! @add_isOwner(u:"createdBy")
  message: String
  nth: String
  title: String! @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  type_: TensionType! @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  emitterid: String! @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  emitter: NodeRef! @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  receiverid: String! @alter_hasRole(n:["receiver"], r: Coordinator, u:"createdBy")
  receiver: NodeRef! @alter_hasRole(n:["receiver"], r: Coordinator, u:"createdBy")
  status: TensionStatus! @alter_hasRole(n:["emitter","receiver"], r: Coordinator, u:"createdBy")
  labels: [LabelRef!] @alter_hasRole(n:["emitter","receiver"], r: Coordinator, u:"createdBy")
  assignees: [UserRef!] @alter_hasRole(n:["emitter","receiver"], r: Coordinator, u:"createdBy")
  action: TensionAction @alter_hasRoot(n:["emitter","receiver"])
  comments: [CommentRef!] @alter_hasRoot(n:["emitter","receiver"])
  blobs: [BlobRef!] @alter_hasRoot(n:["emitter","receiver"])
  history: [EventRef!]! @alter_hasRoot(n:["emitter","receiver"])
  n_comments: Int
  n_blobs: Int
}

type AddTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input AddUserInput {
  createdAt: DateTime!
  username: String! @alter_toLower(f:"username")
  name: String @alter_toLower(f:"name")
  password: String!
  email: String!
  emailHash: String
  emailValidated: Boolean!
  rights: UserRightsRef!
  roles: [NodeRef!] @alter_assertType(f:"roles", t: Role)
  backed_roles: [NodeRef!] @alter_assertType(f:"backed_roles", t: Role)
  tensions_created: [TensionRef!]
  tensions_assigned: [TensionRef!]
  bio: String
  utc: String
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AddUserRightsInput {
  canLogin: Boolean!
  canCreateRoot: Boolean!
}

type AddUserRightsPayload {
  userRights(first: Int, offset: Int): [UserRights]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

input BlobFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  blob_type: BlobType_hash
  pushedFlag: DateTimeFilter
  archivedFlag: DateTimeFilter
  and: BlobFilter
  or: BlobFilter
  not: BlobFilter
}

input BlobOrder {
  asc: BlobOrderable
  desc: BlobOrderable
  then: BlobOrder
}

enum BlobOrderable {
  createdAt
  updatedAt
  message
  pushedFlag
  archivedFlag
  md
}

input BlobPatch {
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String
  tension: TensionRef
  blob_type: BlobType @patch_RO
  pushedFlag: DateTime @alter_RO
  archivedFlag: DateTime @alter_RO
  node: NodeFragmentRef @patch_RO
  md: String @patch_RO
}

input BlobRef {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String
  tension: TensionRef
  blob_type: BlobType
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

input BlobType_hash {
  eq: BlobType!
}

input CommentFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  and: CommentFilter
  or: CommentFilter
  not: CommentFilter
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  createdAt
  updatedAt
  message
  _VOID
}

input CommentPatch {
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String @patch_isOwner(u:"createdBy")
  _VOID: String
}

input CommentRef {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String
  _VOID: String
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  skipIntrospection: Boolean
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
}

type DeleteBlobPayload {
  msg: String
  numUids: Int
}

type DeleteCommentPayload {
  msg: String
  numUids: Int
}

type DeleteEventPayload {
  msg: String
  numUids: Int
}

type DeleteLabelPayload {
  msg: String
  numUids: Int
}

type DeleteMandatePayload {
  msg: String
  numUids: Int
}

type DeleteNodeCharacPayload {
  msg: String
  numUids: Int
}

type DeleteNodeFragmentPayload {
  msg: String
  numUids: Int
}

type DeleteNodePayload {
  msg: String
  numUids: Int
}

type DeletePostPayload {
  msg: String
  numUids: Int
}

type DeleteTensionPayload {
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
}

input EventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  event_type: TensionEvent_hash
  and: EventFilter
  or: EventFilter
  not: EventFilter
}

input EventOrder {
  asc: EventOrderable
  desc: EventOrderable
  then: EventOrder
}

enum EventOrderable {
  createdAt
  updatedAt
  message
  old
  new
}

input EventPatch {
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String
  event_type: TensionEvent
  old: String
  new: String
}

input EventRef {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String
  event_type: TensionEvent
  old: String
  new: String
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
}

input LabelFilter {
  id: [ID!]
  name: StringHashFilter
  and: LabelFilter
  or: LabelFilter
  not: LabelFilter
}

input LabelOrder {
  asc: LabelOrderable
  desc: LabelOrderable
  then: LabelOrder
}

enum LabelOrderable {
  name
  color
}

input LabelPatch {
  color: String
}

input LabelRef {
  id: ID
  name: String
  color: String
}

input MandateFilter {
  id: [ID!]
  purpose: StringFullTextFilter
  and: MandateFilter
  or: MandateFilter
  not: MandateFilter
}

input MandateOrder {
  asc: MandateOrderable
  desc: MandateOrderable
  then: MandateOrder
}

enum MandateOrderable {
  purpose
  responsabilities
  domains
  policies
}

input MandatePatch {
  purpose: String @patch_RO
  responsabilities: String @patch_RO
  domains: String @patch_RO
  policies: String @patch_RO
}

input MandateRef {
  id: ID
  purpose: String
  responsabilities: String
  domains: String
  policies: String
}

enum Mode {
  BATCH
  SINGLE
}

type Mutation {
  addNode(input: [AddNodeInput!]! @hook_addNode): AddNodePayload @hook_addNodePost
  updateNode(input: UpdateNodeInput! @hook_updateNode): UpdateNodePayload @hook_updateNodePost
  deleteNode(filter: NodeFilter!): DeleteNodePayload
  addNodeFragment(input: [AddNodeFragmentInput!]!): AddNodeFragmentPayload
  updateNodeFragment(input: UpdateNodeFragmentInput!): UpdateNodeFragmentPayload
  deleteNodeFragment(filter: NodeFragmentFilter!): DeleteNodeFragmentPayload
  addNodeCharac(input: [AddNodeCharacInput!]!): AddNodeCharacPayload
  updateNodeCharac(input: UpdateNodeCharacInput!): UpdateNodeCharacPayload
  deleteNodeCharac(filter: NodeCharacFilter!): DeleteNodeCharacPayload
  addNodeStats(input: [AddNodeStatsInput!]!): AddNodeStatsPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  deletePost(filter: PostFilter!): DeletePostPayload
  addTension(input: [AddTensionInput!]! @hook_addTension): AddTensionPayload @hook_addTensionPost
  updateTension(input: UpdateTensionInput! @hook_updateTension): UpdateTensionPayload @hook_updateTensionPost
  deleteTension(filter: TensionFilter!): DeleteTensionPayload
  addLabel(input: [AddLabelInput!]!): AddLabelPayload
  updateLabel(input: UpdateLabelInput!): UpdateLabelPayload
  deleteLabel(filter: LabelFilter!): DeleteLabelPayload
  addComment(input: [AddCommentInput!]!): AddCommentPayload
  updateComment(input: UpdateCommentInput! @hook_updateComment): UpdateCommentPayload @hook_updateCommentPost
  deleteComment(filter: CommentFilter!): DeleteCommentPayload
  addBlob(input: [AddBlobInput!]!): AddBlobPayload
  updateBlob(input: UpdateBlobInput!): UpdateBlobPayload
  deleteBlob(filter: BlobFilter!): DeleteBlobPayload
  addEvent(input: [AddEventInput!]!): AddEventPayload
  updateEvent(input: UpdateEventInput!): UpdateEventPayload
  deleteEvent(filter: EventFilter!): DeleteEventPayload
  addMandate(input: [AddMandateInput!]!): AddMandatePayload
  updateMandate(input: UpdateMandateInput!): UpdateMandatePayload
  deleteMandate(filter: MandateFilter!): DeleteMandatePayload
  addUser(input: [AddUserInput!]!): AddUserPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  deleteUser(filter: UserFilter!): DeleteUserPayload
  addUserRights(input: [AddUserRightsInput!]!): AddUserRightsPayload
}

input NodeCharacFilter {
  id: [ID!]
  mode: NodeMode_hash
  userCanJoin: Boolean
  and: NodeCharacFilter
  or: NodeCharacFilter
  not: NodeCharacFilter
}

input NodeCharacPatch {
  mode: NodeMode
  userCanJoin: Boolean
}

input NodeCharacRef {
  id: ID
  mode: NodeMode
  userCanJoin: Boolean
}

input NodeFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  name: StringTermFilter
  nameid: StringHashFilter_StringRegExpFilter
  rootnameid: StringHashFilter_StringRegExpFilter
  type_: NodeType_hash
  about: StringFullTextFilter
  isRoot: Boolean
  isPrivate: Boolean
  isArchived: Boolean
  skills: StringTermFilter
  role_type: RoleType_hash
  and: NodeFilter
  or: NodeFilter
  not: NodeFilter
}

input NodeFragmentFilter {
  id: [ID!]
  not: NodeFragmentFilter
}

input NodeFragmentOrder {
  asc: NodeFragmentOrderable
  desc: NodeFragmentOrderable
  then: NodeFragmentOrder
}

enum NodeFragmentOrderable {
  name
  nameid
  about
  first_link
  second_link
  skills
}

input NodeFragmentPatch {
  name: String
  nameid: String @alter_toLower(f:"nameid")
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharacRef
  about: String @alter_maxLength(f:"about", n:280)
  mandate: MandateRef
  children: [NodeFragmentRef!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

input NodeFragmentRef {
  id: ID
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharacRef
  about: String
  mandate: MandateRef
  children: [NodeFragmentRef!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

input NodeMode_hash {
  eq: NodeMode!
}

input NodeOrder {
  asc: NodeOrderable
  desc: NodeOrderable
  then: NodeOrder
}

enum NodeOrderable {
  createdAt
  name
  nameid
  rootnameid
  about
  n_tensions_out
  n_tensions_in
  n_children
  skills
}

input NodePatch {
  createdAt: DateTime @patch_RO
  createdBy: UserRef @patch_RO
  name: String @patch_hasRole(n:["parent"], r: Coordinator)
  rootnameid: String @patch_RO
  parent: NodeRef @patch_RO
  children: [NodeRef!] @patch_RO
  type_: NodeType @patch_RO
  tensions_out: [TensionRef!] @patch_RO
  tensions_in: [TensionRef!] @patch_hasRole(n:["parent"], r: Coordinator)
  about: String @patch_hasRole(n:["parent"], r: Coordinator)
  mandate: MandateRef @patch_hasRole(n:["parent"], r: Coordinator)
  docs: [TensionRef] @patch_RO
  source: TensionRef @patch_RO
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats: NodeStatsRef
  isRoot: Boolean @patch_RO
  isPrivate: Boolean @patch_RO
  isArchived: Boolean @patch_RO
  charac: NodeCharacRef @patch_hasRole(n:["parent"], r: Coordinator)
  first_link: UserRef @patch_hasRole(n:["parent"], r: Coordinator)
  second_link: UserRef @patch_hasRole(n:["parent"], r: Coordinator)
  skills: [String!] @patch_hasRole(n:["parent"], r: Coordinator)
  role_type: RoleType @patch_hasRole(n:["parent"], r: Coordinator)
}

input NodeRef {
  id: ID
  createdAt: DateTime
  createdBy: UserRef
  name: String
  nameid: String
  rootnameid: String
  parent: NodeRef
  children: [NodeRef!]
  type_: NodeType
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  about: String
  mandate: MandateRef
  docs: [TensionRef]
  source: TensionRef
  n_tensions_out: Int
  n_tensions_in: Int
  n_children: Int
  stats: NodeStatsRef
  isRoot: Boolean
  isPrivate: Boolean
  isArchived: Boolean
  charac: NodeCharacRef
  first_link: UserRef
  second_link: UserRef
  skills: [String!]
  role_type: RoleType
}

input NodeStatsOrder {
  asc: NodeStatsOrderable
  desc: NodeStatsOrderable
  then: NodeStatsOrder
}

enum NodeStatsOrderable {
  n_member
  n_guest
  n_circle
  n_role
}

input NodeStatsRef {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

input NodeType_hash {
  eq: NodeType!
}

input PostFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  and: PostFilter
  or: PostFilter
  not: PostFilter
}

input PostOrder {
  asc: PostOrderable
  desc: PostOrderable
  then: PostOrder
}

enum PostOrderable {
  createdAt
  updatedAt
  message
}

input PostPatch {
  createdAt: DateTime @patch_RO
  updatedAt: DateTime @patch_isOwner(u:"createdBy")
  createdBy: UserRef @patch_RO
  message: String @patch_isOwner(u:"createdBy")
}

input PostRef {
  id: ID!
}

type Query {
  getNode(id: ID, nameid: String): Node
  queryNode(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  getNodeFragment(id: ID!): NodeFragment
  queryNodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  getNodeCharac(id: ID!): NodeCharac
  queryNodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  queryNodeStats(order: NodeStatsOrder, first: Int, offset: Int): [NodeStats]
  getPost(id: ID!): Post
  queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  getTension(id: ID!): Tension
  queryTension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  getLabel(id: ID, name: String): Label
  queryLabel(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  getBlob(id: ID!): Blob
  queryBlob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  getEvent(id: ID!): Event
  queryEvent(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  getMandate(id: ID!): Mandate
  queryMandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  getUser(id: ID, username: String): User
  queryUser(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  queryUserRights(first: Int, offset: Int): [UserRights]
}

input RoleType_hash {
  eq: RoleType
}

input StringExactFilter {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  regexp: String
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

input TensionEvent_hash {
  eq: TensionEvent!
}

input TensionFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  nth: StringTermFilter
  title: StringFullTextFilter
  type_: TensionType_hash
  emitterid: StringHashFilter_StringRegExpFilter
  receiverid: StringHashFilter_StringRegExpFilter
  status: TensionStatus_hash
  and: TensionFilter
  or: TensionFilter
  not: TensionFilter
}

input TensionOrder {
  asc: TensionOrderable
  desc: TensionOrderable
  then: TensionOrder
}

enum TensionOrderable {
  createdAt
  updatedAt
  message
  nth
  title
  emitterid
  receiverid
  n_comments
  n_blobs
}

input TensionPatch {
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef @patch_RO
  message: String
  nth: String
  title: String @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  type_: TensionType @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  emitterid: String @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  emitter: NodeRef @alter_hasRole(n:["emitter"], r: Coordinator, u:"createdBy")
  receiverid: String @alter_hasRole(n:["receiver"], r: Coordinator, u:"createdBy")
  receiver: NodeRef @alter_hasRole(n:["receiver"], r: Coordinator, u:"createdBy")
  status: TensionStatus @alter_hasRole(n:["emitter","receiver"], r: Coordinator, u:"createdBy")
  labels: [LabelRef!] @alter_hasRole(n:["emitter","receiver"], r: Coordinator, u:"createdBy")
  assignees: [UserRef!] @alter_hasRole(n:["emitter","receiver"], r: Coordinator, u:"createdBy")
  action: TensionAction @alter_hasRoot(n:["emitter","receiver"])
  comments: [CommentRef!] @alter_hasRoot(n:["emitter","receiver"])
  blobs: [BlobRef!] @alter_hasRoot(n:["emitter","receiver"])
  history: [EventRef!] @alter_hasRoot(n:["emitter","receiver"])
  n_comments: Int
  n_blobs: Int
}

input TensionRef {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UserRef
  message: String
  nth: String
  title: String
  type_: TensionType
  emitterid: String
  emitter: NodeRef
  receiverid: String
  receiver: NodeRef
  status: TensionStatus
  labels: [LabelRef!]
  assignees: [UserRef!]
  action: TensionAction
  comments: [CommentRef!]
  blobs: [BlobRef!]
  history: [EventRef!]
  n_comments: Int
  n_blobs: Int
}

input TensionStatus_hash {
  eq: TensionStatus!
}

input TensionType_hash {
  eq: TensionType!
}

input UpdateBlobInput {
  filter: BlobFilter!
  set: BlobPatch
  remove: BlobPatch
}

type UpdateBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input UpdateEventInput {
  filter: EventFilter!
  set: EventPatch
  remove: EventPatch
}

type UpdateEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input UpdateLabelInput {
  filter: LabelFilter!
  set: LabelPatch
  remove: LabelPatch
}

type UpdateLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input UpdateMandateInput {
  filter: MandateFilter!
  set: MandatePatch
  remove: MandatePatch
}

type UpdateMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input UpdateNodeCharacInput {
  filter: NodeCharacFilter!
  set: NodeCharacPatch
  remove: NodeCharacPatch
}

type UpdateNodeCharacPayload {
  nodeCharac(filter: NodeCharacFilter, first: Int, offset: Int): [NodeCharac]
  numUids: Int
}

input UpdateNodeFragmentInput {
  filter: NodeFragmentFilter!
  set: NodeFragmentPatch
  remove: NodeFragmentPatch
}

type UpdateNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input UpdateNodeInput {
  filter: NodeFilter!
  set: NodePatch
  remove: NodePatch
}

type UpdateNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input UpdatePostInput {
  filter: PostFilter!
  set: PostPatch
  remove: PostPatch
}

type UpdatePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  numUids: Int
}

input UpdateTensionInput {
  filter: TensionFilter!
  set: TensionPatch
  remove: TensionPatch
}

type UpdateTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter
  email: StringHashFilter
  and: UserFilter
  or: UserFilter
  not: UserFilter
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  createdAt
  username
  name
  password
  email
  emailHash
  bio
  utc
}

input UserPatch {
  createdAt: DateTime @patch_RO
  name: String @patch_isOwner @alter_toLower(f:"name")
  password: String @patch_isOwner
  email: String @patch_isOwner
  emailHash: String @patch_RO
  emailValidated: Boolean @patch_RO
  rights: UserRightsRef @patch_RO
  roles: [NodeRef!] @patch_RO @alter_assertType(f:"roles", t: Role)
  backed_roles: [NodeRef!] @patch_RO @alter_assertType(f:"backed_roles", t: Role)
  tensions_created: [TensionRef!]
  tensions_assigned: [TensionRef!]
  bio: String @patch_isOwner
  utc: String @patch_isOwner
}

input UserRef {
  id: ID
  createdAt: DateTime
  username: String
  name: String
  password: String
  email: String
  emailHash: String
  emailValidated: Boolean
  rights: UserRightsRef
  roles: [NodeRef!]
  backed_roles: [NodeRef!]
  tensions_created: [TensionRef!]
  tensions_assigned: [TensionRef!]
  bio: String
  utc: String
}

input UserRightsRef {
  canLogin: Boolean
  canCreateRoot: Boolean
}
