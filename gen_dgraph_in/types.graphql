


type Node  {
  id: ID!
  createdBy: User!
  createdAt: DateTime! @search
  updatedAt: DateTime
  name: String! @search(by: [term])
  nameid: String! @search(by: [hash, regexp]) @id
  rootnameid: String! @search(by: [hash, regexp])
  parent: Node
  children: [Node!] @hasInverse(field: parent)
  type_: NodeType! @search
  tensions_out: [Tension!] @hasInverse(field: emitter)
  tensions_in: [Tension!] @hasInverse(field: receiver)
  about: String @search(by: [fulltext])
  mandate: Mandate
  docs: [Blob]
  source: Blob
  n_tensions_out: Int 
  n_tensions_in: Int 
  n_children: Int 
  stats: NodeStats 
  isRoot: Boolean! @search
  isPersonal: Boolean @search
  isPrivate: Boolean! @search
  isArchived: Boolean! @search
  charac: NodeCharac!
  labels: [Label!]
  first_link: User
  second_link: User
  skills: [String!] @search(by: [term])
  role_type: RoleType @search
  contracts: [Vote!] @hasInverse(field: node)
  shared: SharedNode
}

type SharedNode {
  n_labels: Int
  n_tensions: Int
  n_closed_tensions: Int
}

type NodeFragment {
  id: ID!
  name: String
  nameid: String
  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharac
  about: String
  mandate: Mandate
  children: [NodeFragment!]
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

type Mandate {
  id: ID!
  purpose: String! @search(by: [fulltext])
  responsabilities: String
  domains: String
  policies: String
}

type NodeCharac {
  id: ID!
  userCanJoin: Boolean! @search
  mode: NodeMode! @search
}

type NodeStats {
  n_member: Int
  n_guest: Int
  n_circle: Int
  n_role: Int
}

interface Post {
  id: ID!
  createdBy: User!
  createdAt: DateTime! @search
  updatedAt: DateTime
  message: String @search(by: [fulltext])
}

type Tension implements Post  {
  emitterid: String! @search(by: [hash, regexp])
  emitter: Node!
  receiverid: String! @search(by: [hash, regexp])
  receiver: Node!
  nth: String @search
  title: String! @search(by: [fulltext])
  type_: TensionType! @search
  status: TensionStatus! @search
  labels: [Label!]
  assignees: [User!]
  comments: [Comment!]
  action: TensionAction
  blobs: [Blob!] @hasInverse(field: tension)
  contracts: [Contract!] @hasInverse(field: tension)
  history: [Event!]! @hasInverse(field: tension)
  n_comments: Int 
  n_blobs: Int 
}

type Label {
  id: ID!
  rootnameid: String! @search(by: [hash])
  name: String! @search(by: [hash, term])
  description: String
  color: String
  tensions: [Tension!] @hasInverse(field: labels)
  nodes: [Node!] @hasInverse(field: labels)
  n_nodes: Int 
  n_tensions: Int 
}

type Comment implements Post{
_VOID: String
}

type Blob implements Post {
  tension: Tension!
  blob_type: BlobType! @search
  pushedFlag: DateTime @search
  archivedFlag: DateTime @search
  node: NodeFragment
  md: String
}

type Event implements Post {
  tension: Tension!
  event_type: TensionEvent! @search
  old: String
  new: String
}

type EventFragment {
  event_type: TensionEvent! @search
  old: String
  new: String
}

type Contract implements Post  {
  event: EventFragment!
  closedAt: DateTime @search
  tension: Tension!
  status: ContractStatus! @search
  contract_type: ContractType! @search
  candidates: [User!] @hasInverse(field: contracts)
  participants: [Vote!] @hasInverse(field: contract)
  comments: [Comment!]
}

type Vote {
  id: ID!
  contract: Contract!
  node: Node!
  data: [Int!]
}

type User {
  id: ID!
  createdAt: DateTime!
  lastAck: DateTime!
  username: String! @id
  name: String
  password: String! 
  email: String! @search(by: [hash]) 
  emailHash: String 
  emailValidated: Boolean! 
  rights: UserRights!
  roles: [Node!] @hasInverse(field: first_link)
  backed_roles: [Node!] @hasInverse(field: second_link)
  tensions_created: [Tension!] @hasInverse(field: createdBy)
  tensions_assigned: [Tension!] @hasInverse(field: assignees)
  contracts: [Contract!] @hasInverse(field: candidates)
  bio: String
  utc: String
}

type UserRights {
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
}

enum NodeType {
  Circle
  Role
}

enum RoleType {


  Owner

  Member

  Guest

  Retired

  Pending


  Coordinator

  Peer

  Bot

}

enum NodeMode {
  Coordinated

  Agile

}

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Operational
  Governance
  Help


}

enum TensionAction {

  NewRole
  NewCircle
  NewMd

  EditRole
  EditCircle
  EditMd

  ArchivedRole
  ArchivedCircle
  ArchivedMd




}

enum TensionEvent {

  Created
  Reopened
  Closed
  TitleUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  BlobCreated
  BlobCommitted

  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoin
  UserLeft
  Moved
}

enum BlobType {

  OnNode
  OnAbout
  OnMandate
  OnFirstLink

  OnDoc

}

enum ContractStatus {
  Open
  Closed
  Canceled
}

enum ContractType {
  AnyCoordoDual
  AnyParticipants

  AnyCoordoSource
  AnyCoordoTarget
}
