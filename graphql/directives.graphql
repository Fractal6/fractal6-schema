
#  Make the field unable to read
directive @hidden on FIELD_DEFINITION

# Count the occurence of the field given in arg (should be list) and add the result in
# the current field definition.
directive @count(f: String!) on FIELD_DEFINITION

# special methogds
directive @meta_getNodeStats on FIELD_DEFINITION

# Hook directive for mutation
# Gqlast automatically append hook in Dgraph Type, as:
#   addNode(input: [AddNodeInput!]! @hook_addNode): AddNodePayload @hook_addNodePost
directive @hook_addNode on ARGUMENT_DEFINITION
directive @hook_addNodePost on FIELD_DEFINITION
directive @hook_updateNode on ARGUMENT_DEFINITION
directive @hook_updateNodePost on FIELD_DEFINITION
directive @hook_addTension on ARGUMENT_DEFINITION
directive @hook_addTensionPost on FIELD_DEFINITION
directive @hook_updateTension on ARGUMENT_DEFINITION
directive @hook_updateTensionPost on FIELD_DEFINITION
directive @hook_updateComment on ARGUMENT_DEFINITION
directive @hook_updateCommentPost on FIELD_DEFINITION

# @DEBUG: Track this to remove the need of the field string value mentionned on input
# https://github.com/99designs/gqlgen/issues/1084

directive @alter_toLower(f: String!) on INPUT_FIELD_DEFINITION

# Limit the max size of the string given in input
directive @alter_maxLength(f: String!, n: Int!) on INPUT_FIELD_DEFINITION

# Ensure the `type_` of a the given (list) Node/Object .See @Debug(#3a99e49)
directive @alter_assertType(f: String!, t: NodeType!) on INPUT_FIELD_DEFINITION

#
# Global object query directive
#
directive @hidePrivate on OBJECT | FIELD_DEFINITION

###########################################################
# Auth (UserCtx)
# Directive code:
# add_* => apply on Add mutation
# patch_* => apply on Update mutation
# alter_* => apply on all mutation input (add and update)
###########################################################

#
# Add and update/patch mutation
#

# Ensure that the user making the request is authenticated.
directive @isAuth on OBJECT | FIELD_DEFINITION 

# Authorize mutations if the user has at least:
# * the given role(r) with the given node(n)
# * the owner/ship against user(u) (if given)
directive @patch_hasRole(n: [String!]!, r: RoleType!, u: String) on INPUT_FIELD_DEFINITION
directive @alter_hasRole(n: [String!]!, r: RoleType!, u: String) on INPUT_FIELD_DEFINITION
 
# Authorize mutation if user has the same root node than at least 
# one of the given node(n) (i.e. is in the same organisation)
directive @alter_hasRoot(n: [String!]!) on INPUT_FIELD_DEFINITION

# @TODO/@DEBUG: if node or user fieldid is not given by the selection set
# do a grpc request to get it !

#
# Auth for update/patch mutation
#

# Authorize update only if the field's value match the user(u) credential.
# If user(u) field is empty, assume a user object.
directive @add_isOwner(u: String) on INPUT_FIELD_DEFINITION
directive @patch_isOwner(u: String) on INPUT_FIELD_DEFINITION

directive @patch_RO on INPUT_FIELD_DEFINITION # for field defined at creation, Non Patchable
directive @alter_RO on INPUT_FIELD_DEFINITION # for field defined at creation, Non Patchable

