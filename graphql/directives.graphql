###########################################################
#
# Reader directives -- work at the field level.
#
###########################################################

#  Make the field unable to read
directive @hidden on FIELD_DEFINITION

# Use for DQL requests.
directive @meta(f: String!, k: String) on FIELD_DEFINITION

# Return true if the user is a authorized validator for the given contract.
directive @isContractValidator on FIELD_DEFINITION

###########################################################
#
# Writer directives -- work at input field level.
#
# add: apply on input fields of Add* queries
# set: (not implemented) apply on input fields of update:set queries
# remove: (not implemented) apply on input fields of update:remove queries
# patch: (not implemented) apply on input fields of update:set + remove) queries (*Patch)
# alter: allows field to be altered (added + set + remove)
#
# Note1: set, remove and patch are equivalent to alter for now. This arise from
#        the difficulty to differentiate the type used for update, remove and delete
#        bacause they all use type like (<type>Patch).
# Note2: deeper object ref (the one where parent are also ref object), are
#        automatically protected with @x_alter(r:"ref")
#
# a:action  The function to be executed on the field.
#
###########################################################

directive @w_add(a:String!) on INPUT_FIELD_DEFINITION
directive @w_set(a:String!) on INPUT_FIELD_DEFINITION
directive @w_remove(a:String!) on INPUT_FIELD_DEFINITION
directive @w_patch(a:String!) on INPUT_FIELD_DEFINITION
directive @w_alter(a:String!) on INPUT_FIELD_DEFINITION
# Use for post hook execution.
directive @w_meta_patch(f:String!, k: String) on INPUT_FIELD_DEFINITION


###########################################################
#
# Authorization directives -- work at the input field level.
# --
# Those directives are automagically generated on corresponding input types.
# see the schema/gqlast.py parser for details.
# --
# By default, If no directive are given for a field,
# the @auth_patch_to is automatically generated on input;
# else-if no arguments are given, the authorization is granted;
# else the function must pass.
#
# r:rule    Optional function that should pass (pass by default ie no argument)
# f:field   Optional field to lookup
# e:event   Optional event
# n:number  Optional integer value
#
###########################################################

# Add rules should be controlled by 1) dgraph @auth rule, 2) schema definition (! field) and 3) @hook_ BLA validation.
directive @x_add(r: String, f: String, e: [TensionEvent!], n:Int) on INPUT_FIELD_DEFINITION
directive @x_set(r: String, f: String, e: [TensionEvent!], n:Int) on INPUT_FIELD_DEFINITION
directive @x_remove(r: String, f: String, e: [TensionEvent!], n:Int) on INPUT_FIELD_DEFINITION
directive @x_patch(r: String, f: String, e: [TensionEvent!], n:Int) on INPUT_FIELD_DEFINITION
directive @x_alter(r: String, f: String, e: [TensionEvent!], n:Int) on INPUT_FIELD_DEFINITION
directive @x_patch_ro on INPUT_FIELD_DEFINITION # [defaut] prevent a field to be patched.
directive @x_ro on INPUT_FIELD_DEFINITION # make a field read-only (for exemple a an optional field that is not allowed to be set by a user.)
                                          # Also Use ot to protect field against deep mutations.



# Hook directive for mutation
# Gqlast automatically append hook in Dgraph Type, like:
#
#   addNode(input: [AddNodeInput!]! @hook_addNodeInput): AddNodePayload @hook_addNode
#   for input

