# <!> Code depencies <!>
# * fractal6.go/web/auth/model: hardocded struct
# * fractal6.go/dp/api: hardocded query
# * fractal6-ui.elm: query and case on enum object 


# Universe (graph of graph)
# @DEBUG: with Union and Node/Leaf (Node = Circle | Role)
#
#type Network {
#  name: String
#  nameid: String
#  nodes: [Node!] @hasInverse(field: network) # root nodes only
#  category: [String!]
#}


#
# Node Interface (Role and Circle)
#

type Node @auth(
  query: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize public data
    { rule: """query {
        queryNode(filter: {visibility: {eq: Public}}) { id }
    }""" },
    # Authorize private data (members only)
    { rule: """query ($ROOTIDS: [String!]) {
        queryNode(filter: {rootnameid: {in: $ROOTIDS}, and: {visibility: {eq: Private}} }) { id }
    }""" },
    # Authorize secret data (explicit member only)
    { rule: """query ($USERNAME: String!) {
        queryNode(filter: {visibility: {eq: Secret}}) {
          children {
              first_link(filter: {username: {eq: $USERNAME}}) { username }
          }
        }
    }""" }
  ]}
) @hook_ {
  id: ID!
  createdBy: User!      @patch_RO
  createdAt: DateTime!  @patch_RO @search 
  updatedAt: DateTime   @alter_RO

  # Node naming/ID
  name: String!        @patch_RO @search(by: [term])
  nameid: String!      @patch_RO @search(by: [hash, regexp]) @id 
  rootnameid: String!  @patch_RO @search(by: [hash, regexp]) # Convenience to recursively access children

  # Node linking
  parent: Node       @patch_RO # If parent is null, Node is a root node
  children: [Node!]  @patch_RO @hasInverse(field: parent) # @DEBUG union for multi edge graph
  type_: NodeType!   @patch_RO @search 

  # Edges
  tensions_out: [Tension!]  @patch_RO @hasInverse(field: emitter) 
  tensions_in: [Tension!]   @patch_RO @hasInverse(field: receiver)

  # Documents, data, etc.
  about: String     @patch_RO @search(by: [fulltext])
  mandate: Mandate  @patch_RO
  docs: [Blob]      @patch_RO
  source: Blob      @patch_RO
  labels: [Label!]  @patch_RO  

  # Node Permission
  visibility: NodeVisibility!  @patch_RO @search # rules of access (R/W)
  mode: NodeMode!              @patch_RO @search # Governance mode (Interpratation of role_type)
  rights: Int!                 @alter_RO # Only used for Bot (v0.5). The right value is a binary AND between all event authorized it the same order they appear in the schema.
  isArchived: Boolean!         @patch_RO @search # Blob source is archived
  # Root node only
  #network: [Network] @hasInverse(field: nodes)
  isRoot: Boolean!      @patch_RO @search 
  isPersonal: Boolean   @patch_RO @search # Help explore "official" orga - nameid ends with @{username}
  userCanJoin: Boolean  @patch_RO # Rather can ask to join 

  # Role... is a Leaf
  first_link: User        @patch_RO
  second_link: User       @patch_RO # @TODO: User a list of users instead (think this as reserve)
  skills: [String!]       @patch_RO @search(by: [term]) 
  role_type: RoleType     @patch_RO @search # @DEBUG: Waiting Nested filter in Dgragh
  role_ext: RoleExt       @patch_RO

  # Interaction
  contracts: [Vote!]      @hasInverse(field: node) # only for Member role -- named role (@...)

  # Aggregator
  orga_agg: OrgaAgg @meta(f:"getOrgaAgg", k:"nameid")
}

type NodeFragment {
  id: ID!
  name: String    @alter_minLength(n:1)
  nameid: String  @alter_toLower

  type_: NodeType
  about: String   @alter_maxLength(n:280)
  mandate: Mandate

  # All the literal below are took into account
  # only when adding a circle.
  # For updates, one need to use the tension Event to update the circle.

  # Charac
  visibility: NodeVisibility
  mode: NodeMode

  # For Circles
  children: [NodeFragment!] # Role only for sub-cirles

  # For Roles
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

type Mandate {
  id: ID!
  purpose: String!  @search(by: [fulltext]) 
  responsabilities: String                  
  domains: String                           
  policies: String                          
}

type Label @auth(
  query: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize public data
    { rule: """query {
        queryLabel { 
          nodes(filter: {visibility: {eq: Public}}) { id }
        }
    }""" },
    # Authorize member 
    { rule: """query ($ROOTIDS: [String!]) {
        queryLabel(filter: {rootnameid: {in: $ROOTIDS}}) { id }
    }""" }
  ]}
) @hook_ {
  id: ID!
  rootnameid: String!  @patch_RO @search(by: [hash])
  name: String!        @search(by: [hash, term]) @alter_unique(on:"rootnameid") @alter_toLower @alter_minLength(n:1)
  description: String  @alter_maxLength(n:280)
  color: String
  tensions: [Tension!] @alter_RO @hasInverse(field: labels)
  nodes: [Node!]       @hasInverse(field: labels) @alter_oneByOne

  # -- @debug : Aggregate count result.
  n_nodes: Int 
  n_tensions: Int
}

type RoleExt @auth(
  query: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize public data
    { rule: """query {
        queryRoleExt { 
          nodes(filter: {visibility: {eq: Public}}) { id }
        }
    }""" },
    # Authorize member 
    { rule: """query ($ROOTIDS: [String!]) {
        queryRoleExt(filter: {rootnameid: {in: $ROOTIDS}}) { id }
    }""" }
  ]}
) @hook_ {
  id: ID!
  rootnameid: String!  @patch_RO @search(by: [hash])
  name: String!        @search(by: [hash, term]) @alter_unique(on:"rootnameid") @alter_toLower @alter_minLength(n:1)
  about: String        @alter_maxLength(n:280)
  role_type: RoleType!
  color: String
  mandate: Mandate
  nodes: [Node!]       @hasInverse(field: role_ext) @alter_oneByOne

  # -- @debug : Aggregate count result.
  n_nodes: Int 
  # period of validity ? @future
  # validatedBy  ? @future (vote process...)
}


type OrgaAgg {
  n_members: Int  # count Guest role (root)
  n_guests: Int   # count member role (root)
}

#
# Post Interface (Tension, Comment, Event, etc)
#

interface Post @auth(
  add: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize author
    { rule: """query ($USERNAME: String!) {
      queryPost {
        createdBy(filter: {username: {eq: $USERNAME}}) { username }
      }
    }""" }
  ]}
){
  id: ID!
  createdBy: User!      @patch_RO 
  createdAt: DateTime!  @patch_RO @search 
  updatedAt: DateTime   @patch_isOwner(u:"createdBy")
  message: String       @patch_isOwner(u:"createdBy") @search(by: [fulltext])
}

type Tension implements Post @auth(
  query: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize public data
    { rule: """query {
        queryTension {
          receiver(filter: {visibility: {eq: Public}}) { id }
        }
    }""" },
    # Authorize private data (members only)
    { rule: """query ($ROOTIDS: [String!]) {
        queryTension {
          receiver(filter: {rootnameid: {in: $ROOTIDS}, and: {visibility: {eq: Private}}}) { id }
        }
    }""" },
    # Authorize secret data (explicit member only)
    { rule: """query ($USERNAME: String!) {
        queryTension {
          receiver(filter: {visibility: {eq: Secret}}) { 
            children {
                first_link(filter: {username: {eq: $USERNAME}}) { username }
            }
          }
        }
    }""" }
  ]},
  add: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize users that own the emitter role
    { rule: """query ($USERNAME: String!) {
        queryTension {
          emitter {
            first_link(filter: {username: {eq: $USERNAME}}) { username }
          }
        }
    }""" },
    # Authorize Bot emitter
    { rule: """query {
        queryTension {
          emitter(filter: {role_type: {eq: Bot}}) { id }
        }
    }""" }
  ]}
) @hook_ {
  emitterid: String!     @patch_RO @search(by: [hash, regexp]) # @DEBUG: Waiting Nested filter in Dgragh
  emitter: Node!         @patch_RO  
  receiverid: String!    @patch_RO @search(by: [hash, regexp]) # @DEBUG: Waiting Nested filter in Dgragh
  receiver: Node!        @patch_RO

  nth: String            @search #...Upsert in BLL
  title: String!         @search(by: [fulltext]) @alter_minLength(n:1)
  type_: TensionType!    @search 
  status: TensionStatus! @search

  assignees: [User!]     
  labels: [Label!]       
  comments: [Comment!]   @alter_oneByOne  
  action: TensionAction  
  blobs: [Blob!]         @hasInverse(field: tension) @alter_oneByOne
  contracts: [Contract!] @hasInverse(field: tension)
  history: [Event!]!     @hasInverse(field: tension) # entry point

  # -- @debug : Aggregate count result.
  # We need thiss field to count things with DQL request since it is not yet
  # possible to return a Aggregate cout result in the DQL response.
  n_comments: Int
  n_open_contracts: Int
}

type Comment implements Post @auth(
  update: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize author
    { rule: """query ($USERNAME: String!) {
      queryComment {
        createdBy(filter: {username: {eq: $USERNAME}}) { username }
      }
    }""" }
  ]}
) @hook_ {
  message: String!  @search(by: [fulltext]) 
}

type Blob implements Post {
  tension: Tension!
  blob_type: BlobType!    @patch_RO @search
  pushedFlag: DateTime    @alter_RO @search
  archivedFlag: DateTime  @alter_RO @search

  # data
  node: NodeFragment @patch_RO
  md: String         @patch_RO
}

type Event implements Post {
  tension: Tension!
  event_type: TensionEvent! @search
  old: String # Store blobid for Commit and Pushed event
  new: String # updated value
}

type EventFragment {
  event_type: TensionEvent! @search
  old: String # Store blobid for Commit and Pushed event
  new: String # updated value
}

type Contract implements Post @auth(
  query: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize public data
    { rule: """query {
        queryContract {
          tension { receiver(filter: {visibility: {eq: Public}}) { id } }
        }
    }""" },
    # Authorize private data (members only)
    { rule: """query ($ROOTIDS: [String!]) {
        queryContract {
          tension { receiver(filter: {rootnameid: {in: $ROOTIDS}, and: {visibility: {eq: Private}}}) { id } }
        }
    }""" },
    # Authorize secret data (explicit member only)
    { rule: """query ($USERNAME: String!) {
        queryContract {
          tension { 
            receiver(filter: {visibility: {eq: Secret}}) { 
              children {
                  first_link(filter: {username: {eq: $USERNAME}}) { username }
              }
            }
          }
        }
    }""" }
  ]}
) @hook_ {
  # {contractid} is used to perform upsert update of vote and prevent for creating several 
  # auto similar contract. Contractid is set to uid once the contract is closed to prevent blocking
  # the creation of new contract.
  contractid: String! @id # {receiverid}#{TensionEvent}#old#new
  tension: Tension!                    @patch_RO
  status: ContractStatus!      @search @patch_RO
  contract_type: ContractType! @search @patch_RO
  closedAt: DateTime           @search @patch_RO 
  event: EventFragment!                @patch_RO
  candidates: [User!]     @hasInverse(field: contracts) @patch_RO 
  participants: [Vote!]!  @hasInverse(field: contract)  @patch_RO # only user node (@...)                  
  comments: [Comment!] 
  isValidator: Boolean    @isContractValidator
}

type Vote implements Post @auth(
  add: { or: [
    # Authorize root 
    { rule: "{ $USERTYPE: {eq: \"Root\"} }" },
    # Authorize user with role
    { rule: """query ($USERNAME: String!) {
      queryVote {
        node { first_link(filter: {username: {eq: $USERNAME}}) { username } }
      }
    }""" }
  ]}
) @hook_ {
  # @debug: a vote should trigger a notification but its not evented (contract updated ?)
  id: ID!
  voteid: String!  @id # {contractid}#{nameid}
  contract: Contract!
  node: Node! # Named Role (@...)
  data: [Int!]! # Vote results. Maximum len equal len of candidates.
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime! @alter_RO
  lastAck: DateTime!   @alter_RO
  username: String!  @id @patch_RO @alter_toLower
  name: String       @patch_isOwner 
  password: String!  @patch_isOwner @hidden 
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  email: String!     @patch_isOwner @search(by: [hash]) @hidden
  emailHash: String        @alter_RO @hidden 
  emailValidated: Boolean! @alter_RO @hidden 
  # User Rights
  rights: UserRights! @alter_RO
  # User Roles
  roles: [Node!]        @hasInverse(field: first_link)  @alter_RO
  backed_roles: [Node!] @hasInverse(field: second_link) @alter_RO
  # User Tensions
  tensions_created: [Tension!] @hasInverse(field: createdBy) @alter_RO
  tensions_assigned: [Tension!] @hasInverse(field: assignees) @alter_RO
  contracts: [Contract!] @hasInverse(field: candidates) @alter_RO
  # Profile
  bio: String @patch_isOwner
  utc: String @patch_isOwner
  #skills
}

# Special rights
type UserRights {
  # Managed in auth handler functions
  canLogin: Boolean!
  # Managed by directives
  canCreateRoot: Boolean! # Bypass input Node authorization/limitation.
  maxPublicOrga: Int! # maximum of private organisation
  type_: UserType!
}

#
# Enum
#

### Node

enum NodeType {
  Circle
  Role
}

enum RoleType { # LeafType
  # Member Type
  Owner # Root member
  Member # member with roles
  Guest # member with no roles
  Retired # Retired member
  Pending # Invited member @todo
  # Role
  Coordinator # Local admin Role
  Peer # Regular Role
  Bot # Aggregator, Bridge etc
}

enum NodeVisibility {
  Public # The entire world
  Private # Only the Organisation members
  Secret # Only the authorized Roles
}

enum NodeMode {
  Coordinated # Coordinator centered
  Agile # Role centered
}

### Tension

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Operational
  Governance
  Help
  # Alert # BotAlert. Circle can emit tension ?
  # Poll ?
}

enum TensionAction {
  # Creating
  NewRole
  NewCircle
  NewMd
  # Updating
  EditRole 
  EditCircle 
  EditMd
  # Archiving
  ArchivedRole
  ArchivedCircle
  ArchivedMd
  # -- Extra
  # * Poll ?
  # * Annoucement ?
  # * Articles ?
}

enum TensionEvent {
  # Tension patch
  Created
  Reopened
  Closed
  TitleUpdated
  TypeUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  BlobCreated
  BlobCommitted
  # --- Trigger Action ---
  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoined
  UserLeft
  MemberLinked
  MemberUnlinked
  Authority
  Visibility
  Moved
}

enum BlobType {
  # Node
  OnNode
  OnAbout
  OnMandate
  # Doc (md, spreadsheet, etc)
  OnDoc
  #OnDocTitle ?
}

### Contract

enum ContractStatus {
  Open
  Closed 
  Canceled
}

enum ContractType { # Validation type
  # Both coordinators should validate (both are taken from event.old (==tension.receiver.nameid) and event.new
  AnyCoordoDual
  # Validate on given participants
  AnyCandidates
  # -- self contract
  # Validate on the tension emitter node
  AnyCoordoSource
  # Validate on the tension receiver node
  AnyCoordoTarget
}

### User

enum UserType {
  Regular
  Root  # Sytem only
}


# Dgraph.Authorization {"VerificationKey":"checkJwkToken_or_pubkey","Header":"X-Frac6-Auth","Namespace":"https://fractale.co/jwt/claims","Algo":"HS256"}
