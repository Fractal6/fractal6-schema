# <!> Code depencies:
# * fractal6.go/web/auth/model: reference to typeName
# * fractal6.go/web/auth/dgraph: when typeName is invoked
# * fractal6-ui.elm: case on enumeration object (NodeType, TensionType ,etc)

#
# Node Interface
#
type Node {
  id: ID!
  createdAt: DateTime!  @patch_RO @search 
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 

  # Node linking
  
  # If parent is null, Node is a root node !
  parent: Node       @patch_RO
  children: [Node!]  @patch_RO @hasInverse(field: parent) # @DEBUG union for multi edge graph
  type_: NodeType!   @patch_RO @search 

  # Node naming/ID
 
  name: String!        @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [term])
  nameid: String!      @patch_RO @id
  rootnameid: String!  @patch_RO @search(by: [hash]) # to recursively get children object in GraphQL.

  ### Node Data/attributes
  
  mandate: Mandate @patch_hasRole(n:["parent"], r:Coordinator)
  
  tensions_out: [Tension!]  @hasInverse(field: emitter)  @patch_RO
  tensions_in: [Tension!]   @hasInverse(field: receiver) @patch_RO

  n_tensions_out: Int  @count(f: tensions_out)
  n_tensions_in: Int   @count(f: tensions_in)
  n_children: Int      @count(f: children)

  # @Debug(#3a99e49): when **union** will be available in Dgraph,
  # Consider using a union `union Node = Role | Circle` with a common SuperNode interface.
  # Furthermore, required field (role_type, charac, can have no semantics depending if tis on Role or Circle

  # Circle... is a Supernode/HyperEdge
  isRoot: Boolean!  @patch_RO @search 

  # Role... is a Leaf
  first_link: User      @patch_hasRole(n:["parent"], r:Coordinator)
  second_link: User     @patch_hasRole(n:["parent"], r:Coordinator)
  skills: [String!]     @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [term]) 
  role_type: RoleType   @patch_hasRole(n:["parent"], r:Coordinator) @search

  # Root... inherits attributes
  charac: NodeCharac!  @patch_hasRole(n:["parent"], r:Coordinator)
}

type NodeCharac {
  userCanJoin: Boolean!
  mode: NodeMode!
}

#
# Post Interface
#
interface Post {
  id: ID!
  createdAt: DateTime!  @patch_RO @search 
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 
  message: String  @patch_isOwner(u:"createdBy") @search(by: [fulltext])
}


type Tension implements Post {
  nth: String  @search # @id...Upsert in BLL
  title: String!        @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search(by: [term])
  type_: TensionType!   @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search 
  emitter: Node!        @alter_hasRoot(n:["emitter"]) @patch_RO
  receiver: Node!       @alter_hasRoot(n:["receiver"]) @alter_hasRole(n:["receiver"], r:Coordinator, u:"createdBy")
  comments: [Comment!]  @alter_hasRoot(n:["emitter", "receiver"])
  labels: [Label!]      @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")
  status: TensionStatus! @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy") @search
  action: TensionAction @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")
  mandate: Mandate      @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")

  # Automatic field
  n_comments: Int  @count(f: comments)
}


type Comment implements Post {
  message: String!  @patch_isOwner(u:"createdBy") @search(by: [fulltext]) 
}

type Mandate {
  id: ID!
  tensions: [Tension!]! @hasInverse(field: mandate)
  purpose: String!           @patch_RO @search(by: [fulltext])
  responsabilities: String  @patch_RO
  domains: String           @patch_RO
  policies: String           @patch_RO
  # period of validity ? @future
  # validatedBy  ? @future (vote process...)
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime!  @patch_RO
  username: String!     @patch_RO @alter_maxLength(f:"username", n:42) @id 
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  emailValidated: Boolean! @patch_RO @hidden 
  emailHash: String        @patch_RO @hidden 
  email: String!     @patch_isOwner @alter_maxLength(f:"email", n:100) @hidden @search(by: [hash]) 
  #email: String!    @alter_maxLength(f: "email", n: 100) @hidden  @id # Only one @id allowing in dgraph.
  name: String       @patch_isOwner @alter_maxLength(f:"name", n:100)
  password: String!  @patch_isOwner @alter_maxLength(f:"password", n:100) @hidden 
  #
  rights: UserRights! @patch_RO
  #
  roles: [Node!] @hasInverse(field: first_link)         @patch_RO @alter_assertType(f:"roles", t:Role)
  backed_roles: [Node!] @hasInverse(field: second_link) @patch_RO @alter_assertType(f:"backed_roles", t:Role)
  bio: String @patch_isOwner
  utc: String @patch_isOwner
  #skills
}

# Special rights
type UserRights {
  # Managed in auth handler functions
  canLogin: Boolean!
  # Managed by directives
  canCreateRoot: Boolean! # Bypass input Node authorizatino/limitation.
}

#
# Labels
#

type Label {
  id: ID!
  name: String! @id 
  color: String
  #project: Project...
}



#
# Enum
#

enum NodeType {
  Circle
  Role
}

enum TensionType {
  Governance
  Operational
  Personal
  Help
  # Alert # BotAlert. Circle can emit tension ?
  # Poll ?
}

enum RoleType {
  Coordinator
  Member #Â memner with roles
  Guest # member with no roles
  #Retired
}

enum NodeMode {
  Chaos
  Coordinated
}

enum TensionStatus {
  Open
  Closed
}

enum TensionAction {
  # Creating
  NewRole
  NewCircle
  # Updating:
  # * move node parent
  # * delete node
  # * update mandate
}
