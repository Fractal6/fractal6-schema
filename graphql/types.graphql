# <!> Code depencies:
# * fractal6.go/web/auth/model: reference to typeName
# * fractal6.go/web/auth/dgraph: when typeName is invoked
# * fractal6-ui.elm: case on enumeration object (NodeType, TensionType ,etc)

#
# Universe (graph of graph)
#
# @DEBUG: with Union and circle/leaf
#type Network {
#  name: String
#  nameid: String
#  nodes: [Node] @hasInverse(field: network) # root nodes only
#  category: String! 
#}

#
# Node Interface (Role and Circle)
#

type Node @hidePrivate @hook_update {
  id: ID!
  createdBy: User!      @patch_RO
  createdAt: DateTime!  @patch_RO @search 
  updatedAt: DateTime   @alter_RO

  # Node naming/ID
  name: String!        @patch_RO @search(by: [term])
  nameid: String!      @patch_RO @search(by: [hash, regexp]) @id 
  rootnameid: String!  @patch_RO @search(by: [hash, regexp]) # to recursively access children

  # Node linking
  parent: Node       @patch_RO # If parent is null, Node is a root node
  children: [Node!]  @patch_RO @hasInverse(field: parent) # @DEBUG union for multi edge graph
  type_: NodeType!   @patch_RO @search 

  # Edges
  tensions_out: [Tension!]  @patch_RO @hasInverse(field: emitter) 
  tensions_in: [Tension!]   @patch_RO @hasInverse(field: receiver)

  # Documents, data, etc.
  about: String     @patch_RO @search(by: [fulltext])
  mandate: Mandate  @patch_RO
  docs: [Blob]      @patch_RO
  source: Blob      @patch_RO

  # --method--
  n_tensions_out: Int  @count(f: tensions_out)
  n_tensions_in: Int   @count(f: tensions_in)
  n_children: Int      @count(f: children)
  stats: NodeStats     @meta_getNodeStats

  # @Debug(#3a99e49): when **union** will be available in Dgraph,
  # Consider using a union `union Node = Role | Circle` with a common SuperNode interface.
  # Furthermore, required field (role_type, charac, can have no semantics depending if tis on Role or Circle
  
  # Node Properties
  isRoot: Boolean!      @patch_RO @search 
  isPersonal: Boolean   @patch_RO @search # (Not public) nameid ends with @{username}
  isPrivate: Boolean!   @patch_RO @search # Invitation required for an R/W access
  isArchived: Boolean!  @patch_RO @search # (Hidden) Blob source is archived
  charac: NodeCharac!   @patch_RO # Root... inherits attributes
  labels: [Label!]      @patch_RO  #@alter_hasRole(n:["__self__"])

  # Role... is a Leaf
  first_link: User      @patch_RO
  second_link: User     @patch_RO
  skills: [String!]     @patch_RO @search(by: [term]) 
  role_type: RoleType   @patch_RO @search

  # Root node only
  shared: SharedNode @alter_RO
  #network: [Network] @hasInverse(field: nodes)

}

type SharedNode {
  # This could be utsful to avoid compute count again and again
  # store count and incremets
  # * number of guest
  # * number of members
  # * number of role
  # * number of labels
  # * number of tensions
  # * number of comments
  # * number of circle
  # * number of project
  n_labels: Int
  n_tensions: Int # open and closed
  n_closed_tensions: Int #Closed
}

type NodeFragment {
  id: ID!
  name: String    @alter_minLength(f:"name", n:1)
  nameid: String  @alter_toLower(f:"nameid")

  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharac

  about: String   @alter_maxLength(f:"about", n:280)
  mandate: Mandate

  # For Circles
  children: [NodeFragment!] # Role only for sub-cirles

  # For Roles
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType
}

type NodeCharac {
  id: ID!
  # define the governance process
  userCanJoin: Boolean!  @search
  mode: NodeMode!        @search
}

type NodeStats {
  n_member: Int  # count Guest role (root)
  n_guest: Int   # count member role (root)
  n_circle: Int  # recursively count sub circle
  n_role: Int    # recursively count Peer role
}

#
# Post Interface (Tension, Comment, Event, etc)
#

interface Post {
  id: ID!
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 
  createdAt: DateTime!  @patch_RO @search 
  updatedAt: DateTime   @patch_isOwner(u:"createdBy")
  message: String       @patch_isOwner(u:"createdBy") @search(by: [fulltext])
}

type Tension implements Post @hidePrivate @hook_add @hook_update {
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 

  nth: String  @search # @id...Upsert in BLL
  title: String!           @alter_hasRole(n:["emitter"], u:"createdBy", a:1) @search(by: [fulltext]) @alter_minLength(f:"title", n:1)
  type_: TensionType!      @alter_hasRole(n:["emitter"], u:"createdBy", a:1) @search 
  emitterid: String!       @alter_hasRole(n:["emitter"], u:"createdBy", a:1) @search(by: [hash, regexp]) 
  emitter: Node!           @alter_hasRole(n:["emitter"], u:"createdBy", a:1)  
  receiverid: String!      @alter_hasRole(n:["receiver"], u:"createdBy", a:1) @search(by: [hash, regexp]) 
  receiver: Node!          @alter_hasRole(n:["receiver"], u:"createdBy", a:1)
  status: TensionStatus!   @alter_hasRole(n:["emitter","receiver"], u:"createdBy", a:1) @search
  labels: [Label!]       @patch_hasRole(n:["emitter","receiver"], u:"createdBy", a:1) 
  assignees: [User!]       @alter_hasRole(n:["emitter","receiver"], a:1)
  comments: [Comment!]   @alter_hasRoot(n:["emitter","receiver"])
  action: TensionAction  @alter_hasRoot(n:["emitter","receiver"])
  blobs: [Blob!]         @alter_hasRoot(n:["emitter","receiver"]) @hasInverse(field: tension)
  history: [Event!]!     # entry point

  # --method--
  n_comments: Int  @count(f: comments)
  n_blobs: Int  @count(f: blobs)
}

type Label @hook_add @hook_update {
  id: ID!
  rootnameid: String!  @search(by: [hash]) @patch_RO
  name: String!        @search(by: [hash, term]) @alter_toLower(f:"name")  @alter_unique(f:"name", s:"rootnameid") @alter_minLength(f:"name", n:1)
  description: String  @alter_maxLength(f:"description", n:280)
  color: String
  tensions: [Tension!] @hasInverse(field: labels) @alter_RO
  nodes: [Node!] @hasInverse(field: labels)

  # --method--
  n_nodes: Int     @count(f: nodes)
  n_tensions: Int  @count(f: tensions)
}

type Comment implements Post @hook_update {
  message: String!  @patch_isOwner(u:"createdBy") @search(by: [fulltext]) 
}

type Blob implements Post {
  tension: Tension!
  blob_type: BlobType! @patch_RO @search
  pushedFlag: DateTime @alter_RO @search
  archivedFlag: DateTime @alter_RO @search

  # data
  node: NodeFragment @patch_RO
  md: String @patch_RO
}

type Event implements Post {
  event_type: TensionEvent! @search
  old: String # Store blobid for Commit and Pushed event
  new: String #
}

type Mandate {
  id: ID!
  purpose: String!  @search(by: [fulltext]) @patch_RO 
  responsabilities: String  @patch_RO
  domains: String           @patch_RO
  policies: String          @patch_RO
  # period of validity ? @future
  # validatedBy  ? @future (vote process...)
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime! @alter_RO
  lastAck: DateTime!   @alter_RO
  username: String!  @id @patch_RO  @alter_toLower(f:"username")
  name: String       @patch_isOwner 
  password: String!  @patch_isOwner @hidden 
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  email: String!     @patch_isOwner @search(by: [hash]) @hidden # Only one @id allowing in dgraph.
  emailHash: String        @alter_RO @hidden 
  emailValidated: Boolean! @alter_RO @hidden 
  # User Rights
  rights: UserRights! @alter_RO
  # User Roles
  roles: [Node!]        @hasInverse(field: first_link)  @alter_RO
  backed_roles: [Node!] @hasInverse(field: second_link) @alter_RO
  # User Tensions
  tensions_created: [Tension!] @hasInverse(field: createdBy)
  tensions_assigned: [Tension!] @hasInverse(field: assignees)
  # Profile
  bio: String @patch_isOwner
  utc: String @patch_isOwner
  #skills
}

# Special rights
type UserRights {
  # Managed in auth handler functions
  canLogin: Boolean!
  # Managed by directives
  canCreateRoot: Boolean! # Bypass input Node authorization/limitation.
  maxPublicOrga: Int! # maximum of private organisation
}

#
# Enum
#

### Node

enum NodeType {
  Circle
  Role
}

enum RoleType { # LeafType
  # Member Type
  Owner # Root member
  Member # member with roles
  Guest # member with no roles
  Retired # Retired member
  # Role
  Coordinator # Local admin Role
  Peer # Regular Role
  Bot # Aggregator, Bridge etc
}

enum NodeMode {
  Coordinated # Coordinator centered
  Agile # Role centered
}

### Tension

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Operational
  Governance
  Help
  # Alert # BotAlert. Circle can emit tension ?
  # Poll ?
}

enum TensionAction {
  # Creating
  NewRole
  NewCircle
  NewMd
  # Updating
  EditRole 
  EditCircle 
  EditMd
  # Archiving
  ArchivedRole
  ArchivedCircle
  ArchivedMd
  # -- Extra
  # * Poll ?
  # * Annoucement ?
  # * Articles ?
}

enum TensionEvent {
  # Tension patch
  Created
  Reopened
  Closed
  TitleUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  # EmitterUpdated
  # ReceiverUpdated
  # Blob action
  BlobCreated
  BlobCommitted
  # --- Trigger Event ---
  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoin
  UserLeft
}

enum BlobType {
  # Node
  OnNode
  OnAbout
  OnMandate
  OnFirstLink
  # Doc (md, spreadsheet, etc)
  OnDoc
  #OnDocTitle ?
}

