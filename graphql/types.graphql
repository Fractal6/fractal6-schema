# <!> Code depencies:
# * fractal6.go/web/auth/model: reference to typeName
# * fractal6.go/web/auth/dgraph: when typeName is invoked
# * fractal6-ui.elm: case on enumeration object (NodeType, TensionType ,etc)

#
# Universe (graph of graph)
#
# @DEBUG: with Union and circle/leaf
#type Network {
#  name: String
#  nameid: String
#  nodes: [Node] @hasInverse(field: network) # root nodes only
#  category: String! 
#}

#
# Node Interface (Role and Circle)
#

type Node @hidePrivate @hook_add @hook_update {
  id: ID!
  createdAt: DateTime!  @patch_RO @search 
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 

  # Node naming/ID
  name: String!        @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [term])
  nameid: String!  @id @patch_RO @search(by: [hash, regexp])
  rootnameid: String!  @patch_RO @search(by: [hash, regexp]) # to recursively access children

  # Node linking
  parent: Node       @patch_RO # If parent is null, Node is a root node
  children: [Node!]  @patch_RO @hasInverse(field: parent) # @DEBUG union for multi edge graph
  type_: NodeType!   @patch_RO @search 

  # Edges
  tensions_out: [Tension!]  @hasInverse(field: emitter)  @patch_RO
  tensions_in: [Tension!]   @hasInverse(field: receiver) @patch_hasRole(n:["parent"], r:Coordinator)

  # Documents, data, etc.
  about: String     @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [fulltext])
  mandate: Mandate  @patch_hasRole(n:["parent"], r:Coordinator)
  docs: [Tension]   @patch_RO
  source: Tension   @patch_RO

  # --method--
  n_tensions_out: Int  @count(f: tensions_out)
  n_tensions_in: Int   @count(f: tensions_in)
  n_children: Int      @count(f: children)
  stats: NodeStats  @meta_getNodeStats

  # @Debug(#3a99e49): when **union** will be available in Dgraph,
  # Consider using a union `union Node = Role | Circle` with a common SuperNode interface.
  # Furthermore, required field (role_type, charac, can have no semantics depending if tis on Role or Circle

  # Circle... is a Supernode/HyperEdge
  isRoot: Boolean!     @patch_RO @search 
  isPrivate: Boolean!  @patch_RO @search # Invitation required for an R/W access
  charac: NodeCharac!  @patch_hasRole(n:["parent"], r:Coordinator) # Root... inherits attributes
  #network: [Network] @hasInverse(field: nodes)

  # Role... is a Leaf
  first_link: User      @patch_hasRole(n:["parent"], r:Coordinator)
  second_link: User     @patch_hasRole(n:["parent"], r:Coordinator)
  skills: [String!]     @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [term]) 
  role_type: RoleType   @patch_hasRole(n:["parent"], r:Coordinator) @search

}

type NodeFragment {
  id: ID!
  name: String
  nameid: String @alter_toLower(f:"nameid")

  type_: NodeType
  isPrivate: Boolean
  charac: NodeCharac

  about: String  @alter_maxLength(f:"about", n:280)
  mandate: Mandate

  # For Circles
  children: [NodeFragment!] # Role only for sub-cirles

  # For Roles
  first_link: String
  second_link: String
  skills: [String!]
  role_type: RoleType

}

type NodeCharac {
  id: ID!
  userCanJoin: Boolean! @search
  # define the governance process
  mode: NodeMode! @search
}

type NodeStats {
  n_member: Int   # count Guest role (root)
  n_guest: Int    # count member role (root)
  n_circle: Int  # recursively count sub circle
  n_role: Int    # recursively count Peer role
}

#
# Post Interface (Tension, Comment, Event, etc)
#

interface Post {
  id: ID!
  createdAt: DateTime!  @patch_RO @search 
  updatedAt: DateTime   @patch_isOwner(u:"createdBy")
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 
  message: String  @patch_isOwner(u:"createdBy") @search(by: [fulltext])
}


type Tension implements Post @hook_add @hook_update {
  nth: String  @search # @id...Upsert in BLL
  title: String!         @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search(by: [fulltext])
  type_: TensionType!    @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search 
  emitter: Node!         @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy")  
  emitterid: String!     @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search(by: [hash, regexp]) 
  receiver: Node!        @alter_hasRole(n:["receiver"],r:Coordinator, u:"createdBy")
  receiverid: String!    @alter_hasRole(n:["receiver"],r:Coordinator, u:"createdBy") @search(by: [hash, regexp]) 
  status: TensionStatus! @alter_hasRole(n:["emitter","receiver"], r:Coordinator, u:"createdBy") @search
  action: TensionAction    @alter_hasRoot(n:["emitter","receiver"])
  labels: [Label!]       @alter_hasRole(n:["emitter","receiver"], r:Coordinator, u:"createdBy")
  comments: [Comment!]     @alter_hasRoot(n:["emitter","receiver"])
  blobs: [Blob!]         @alter_hasRole(n:["emitter","receiver"], r:Coordinator, u:"createdBy") @hasInverse(field: tension)
  history: [Event!]!      #...RO ? manage in the BLL

  # --method--
  n_comments: Int  @count(f: comments)
  n_blobs: Int  @count(f: blobs)
}

type Label {
  id: ID!
  name: String! @id 
  color: String
}

type Comment implements Post @hook_update {
  message: String!  @patch_isOwner(u:"createdBy") @search(by: [fulltext]) 
}

type Blob implements Post {
  tension: Tension!
  blob_type: BlobType! @patch_RO @search
  pushedFlag: DateTime @alter_RO @search

  # data
  node: NodeFragment @patch_RO
  md: String @patch_RO
}

type Event implements Post {
  event_type: TensionEvent! @search
  old: String # Store blodid for Commit and Pushed event
  new: String #
}

type Mandate {
  id: ID!
  purpose: String!  @search(by: [fulltext]) @patch_RO 
  responsabilities: String  @patch_RO
  domains: String           @patch_RO
  policies: String          @patch_RO
  # period of validity ? @future
  # validatedBy  ? @future (vote process...)
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime!   @patch_RO
  username: String!  @id @patch_RO  @alter_toLower(f:"username")
  name: String       @patch_isOwner @alter_toLower(f:"name")
  password: String!  @patch_isOwner @hidden 
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  email: String!     @patch_isOwner @search(by: [hash]) @hidden # Only one @id allowing in dgraph.
  emailHash: String        @patch_RO @hidden 
  emailValidated: Boolean! @patch_RO @hidden 
  #
  rights: UserRights! @patch_RO
  #
  roles: [Node!]        @hasInverse(field: first_link)  @patch_RO @alter_assertType(f:"roles", t:Role)
  backed_roles: [Node!] @hasInverse(field: second_link) @patch_RO @alter_assertType(f:"backed_roles", t:Role)
  bio: String @patch_isOwner
  utc: String @patch_isOwner
  #skills
}

# Special rights
type UserRights {
  # Managed in auth handler functions
  canLogin: Boolean!
  # Managed by directives
  canCreateRoot: Boolean! # Bypass input Node authorizatino/limitation.
}

#
# Enum
#

### Node

enum NodeType {
  Circle
  Role
}

enum RoleType { # LeafType
  Coordinator
  Peer # Regular Role
  Member # member with roles
  Guest # member with no roles
  #Retired
}

enum NodeMode {
  Chaos
  Coordinated
}

### Tension

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Governance
  Operational
  Personal
  Help
  # Alert # BotAlert. Circle can emit tension ?
  # Poll ?
}

enum TensionAction {
  # Creating
  NewRole
  NewCircle
  #NewDoc
  # Updating
  EditRole 
  EditCircle 
  #EditDoc 
  # Deleting
  #DeleteRole
  #DeleteCircle
  #DeleteDoc
  #Extra
  # NewPoll
}

enum TensionEvent {
  Created
  Reopened
  Closed
  TitleUpdated
  CommentPushed
  # LabelAdded
  # LabelRemoved
  # EmitterUpdated
  # ReceiverUpdated
  BlobCreated
  BlobCommitted
  BlobPushed
}

enum BlobType {
  OnNode
  OnAbout
  OnMandate
  OnFirstLink
  OnDoc
}

