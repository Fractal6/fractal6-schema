# <!> Code depencies:
# * fractal6.go/web/auth/model: reference to typeName
# * fractal6.go/web/auth/dgraph: when typeName is invoked
# * fractal6-ui.elm: case on enumeration object (NodeType, TensionType ,etc)

#
# Universe (graph of graph)
#
# @DEBUG: wityh Union and circle/leaf
#type Universe {
#  nodes: [Node] @hasInverse(field: universe)
#  category: String! 
#}

#
# Node Interface
#
type Node @hidePrivate {
  id: ID!
  createdAt: DateTime!  @patch_RO @search 
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 

  # Node linking
  parent: Node       @patch_RO # If parent is null, Node is a root node
  children: [Node!]  @patch_RO @hasInverse(field: parent) # @DEBUG union for multi edge graph
  type_: NodeType!   @patch_RO @search 

  # Node naming/ID
  name: String!        @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [term])
  nameid: String!      @patch_RO @id
  rootnameid: String!  @patch_RO @search(by: [hash]) # to recursively get children object in GraphQL.

  # Edges
  tensions_out: [Tension!]  @hasInverse(field: emitter)  @patch_RO
  tensions_in: [Tension!]   @hasInverse(field: receiver) @patch_RO

  # Documents, data...
  mandate: Mandate @patch_hasRole(n:["parent"], r:Coordinator)

  # --method--
  n_tensions_out: Int  @count(f: tensions_out)
  n_tensions_in: Int   @count(f: tensions_in)
  n_children: Int      @count(f: children)
  stats: NodeStats  @meta_getNodeStats

  # @Debug(#3a99e49): when **union** will be available in Dgraph,
  # Consider using a union `union Node = Role | Circle` with a common SuperNode interface.
  # Furthermore, required field (role_type, charac, can have no semantics depending if tis on Role or Circle

  # Circle... is a Supernode/HyperEdge
  isRoot: Boolean!  @patch_RO @search 
  isPrivate: Boolean! @patch_RO @search # Invitation required for an R/W access
  # universe: Universe

  # Role... is a Leaf
  first_link: User      @patch_hasRole(n:["parent"], r:Coordinator)
  second_link: User     @patch_hasRole(n:["parent"], r:Coordinator)
  skills: [String!]     @patch_hasRole(n:["parent"], r:Coordinator) @search(by: [term]) 
  role_type: RoleType   @patch_hasRole(n:["parent"], r:Coordinator) @search

  # Root... inherits attributes
  charac: NodeCharac!  @patch_hasRole(n:["parent"], r:Coordinator)
}

type NodeCharac {
  id: ID!
  userCanJoin: Boolean! @search
  # define the governance process
  mode: NodeMode! @search
}

type NodeStats {
  n_member: Int   # count Guest role (root)
  n_guest: Int    # count member role (root)
  n_circle: Int  # recursively count sub circle
  n_role: Int    # recursively count Peer role
}

#
# Post Interface
#
interface Post {
  id: ID!
  createdAt: DateTime!  @patch_RO @search 
  createdBy: User!      @patch_RO @add_isOwner(u:"createdBy") 
  message: String  @patch_isOwner(u:"createdBy") @search(by: [fulltext])
}


type Tension implements Post {
  nth: String  @search # @id...Upsert in BLL
  title: String!        @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search(by: [fulltext])
  type_: TensionType!   @alter_hasRole(n:["emitter"], r:Coordinator, u:"createdBy") @search 
  emitter: Node!        @alter_hasRoot(n:["emitter"]) @patch_RO
  emitterid: String!    @alter_hasRoot(n:["emitter"]) @patch_RO @search(by: [hash, regexp]) 
  receiver: Node!       @alter_hasRoot(n:["receiver"]) @alter_hasRole(n:["receiver"], r:Coordinator, u:"createdBy")
  receiverid: String!   @alter_hasRoot(n:["receiver"]) @alter_hasRole(n:["receiver"], r:Coordinator, u:"createdBy") @search(by: [hash, regexp]) 
  comments: [Comment!]  @alter_hasRoot(n:["emitter", "receiver"])
  labels: [Label!]      @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")
  status: TensionStatus! @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy") @search
  action: TensionAction  @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")
  mandate: Mandate       @alter_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")

  n_comments: Int  @count(f: comments)

}


type Comment implements Post {
  message: String!  @patch_isOwner(u:"createdBy") @search(by: [fulltext]) 
}

type Mandate {
  id: ID!
  tensions: [Tension!]! @hasInverse(field: mandate)
  purpose: String!          @patch_RO @search(by: [fulltext])
  responsabilities: String  @patch_RO
  domains: String           @patch_RO
  policies: String          @patch_RO
  # period of validity ? @future
  # validatedBy  ? @future (vote process...)
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime!  @patch_RO
  username: String!     @patch_RO @alter_maxLength(f:"username", n:42) @id 
  name: String       @patch_isOwner @alter_maxLength(f:"name", n:100)
  password: String!  @patch_isOwner @alter_maxLength(f:"password", n:100) @hidden 
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  email: String!     @patch_isOwner @alter_maxLength(f:"email", n:100) @hidden @search(by: [hash]) 
  #email: String!    @alter_maxLength(f: "email", n: 100) @hidden  @id # Only one @id allowing in dgraph.
  emailHash: String        @patch_RO @hidden 
  emailValidated: Boolean! @patch_RO @hidden 
  #
  rights: UserRights! @patch_RO
  #
  roles: [Node!] @hasInverse(field: first_link)         @patch_RO @alter_assertType(f:"roles", t:Role)
  backed_roles: [Node!] @hasInverse(field: second_link) @patch_RO @alter_assertType(f:"backed_roles", t:Role)
  bio: String @patch_isOwner
  utc: String @patch_isOwner
  #skills
}

# Special rights
type UserRights {
  # Managed in auth handler functions
  canLogin: Boolean!
  # Managed by directives
  canCreateRoot: Boolean! # Bypass input Node authorizatino/limitation.
}

#
# Labels
#

type Label {
  id: ID!
  name: String! @id 
  color: String
  #project: Project...
}



#
# Enum
#

enum NodeType {
  Circle
  Role
}

enum TensionType {
  Governance
  Operational
  Personal
  Help
  # Alert # BotAlert. Circle can emit tension ?
  # Poll ?
}

enum RoleType { # LeafType
  Coordinator
  Peer # Regular Role
  Member #Â member with roles
  Guest # member with no roles
  #Retired
}

enum NodeMode {
  Chaos
  Coordinated
}

enum TensionStatus {
  Open
  Closed
}

enum TensionAction {
  # Creating
  NewRole
  NewCircle
  #NewLabel
  # Updating:
  #  * UpdateParent
  #  * UpdateEmitter
  #  * UpdateReceiver
  #  * UpdataMandate
  #  * UpdateTitle
  #  * UpdateStatus
  # Deleting:
  #  * DeleteRole
  #  * DeleteCircle
  #  * DeleteLabel
}
