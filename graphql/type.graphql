# <!> Code depencies:
# * fractal6.go/web/auth/model: reference to typeName
# * fractal6.go/web/auth/dgraph: when typeName is invoked
# * fractal6-ui.elm: case on enumeration object (NodeType, TensionType ,etc)

#
# Node Interface
#
type Node {
  id: ID!
  createdAt: DateTime! @search
  createdBy: User! @input_auth(f: "parent", role: Coordinator)

  # DEBUG union for multi edge.
  # If parent is null, Node is a root node !
  parent: Node
  children: [Node!] @hasInverse(field: parent)
  type_: NodeType! @search

  name: String! @search(by: [term])
  nameid: String! @id # Used for URI
  # Index organisation nodes. We use it since it an open issue to get 
  # recursive object from root node.
  rootnameid: String! @search(by: [hash]) 

  mandate: Mandate
  # validatedBy  # @DEBUG: Birth logics?

  tensions_out: [Tension!] @hasInverse(field: emitter)
  tensions_in: [Tension!] @hasInverse(field: receiver)

  n_tensions_out: Int @count(f: tensions_out)
  n_tensions_in: Int @count(f: tensions_in)
  n_children: Int @count(f: children)

  # see @Debug(#3a99e49)
  # Circle...
  isRoot: Boolean! @search

  # Role...
  first_link: User
  second_link: User
  skills: [String!] @search(by: [term])
  role_type: RoleType # <- default to guest when union supported
  #rights: Rights # @future
}

# @Debug(#3a99e49): when **union** will be available in Draph
# Considered using a union for Role = Circle | Role and _Role interface for both.
# ...
## Supernode/Hyperedge
#type Circle implements Node {
#  isRoot: Boolean! @search
#}
#
## Leaf
#type Role implements Node {
#  first_link: User
#  second_link: User
#  skills: [String!] @search(by: [term])
#  #authority: Authority
#}

type Rights {
  open_tension: Boolean
  close_tension: Boolean

  create_circle: Boolean
  remove_circle: Boolean

  create_role: Boolean
  detach_role: Boolean
  remove_role: Boolean
}


#
# Post Interface
#
interface Post {
  id: ID!
  createdAt: DateTime! @search
  createdBy: User!
  message: String @search(by: [fulltext])
  items: [String!] @search(by: [fulltext])# Bullet points
}


type Tension implements Post {
  #isAnonymous: Boolean!
  nth: String @search # @id...Upsert in BLL / Used for URI
  title: String! @search(by: [term])
  type_: TensionType! @search
  emitter: Node! # union @debug (circle can emit tensoin (botAlert))
  receiver: Node! # union @debug (circle or role can receive tension)
  comments: [Comment!]
  labels: [Label!]

  # Automatic field
  n_comments: Int  @count(f: comments)
}


type Comment implements Post {
  message: String! @search(by: [fulltext])
}

type Mandate implements Post {
  purpose: String! @search(by: [fulltext])
  responsabilities: Post
  domains: Post
  # Interface:
  #    period:
  #    canValidateNode
  #    number of validation to be modified ? ....
  #    election ???
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime! @search
  username: String! @id      @input_maxLength(f: "username", n: 42)
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  email: String! @hidden @search(by: [hash]) @input_maxLength(f: "email", n: 100)
  emailHash: String @hidden
  emailValidated: Boolean! @hidden
  #email: String! @id @hidden @input_maxLength(f: "email", n: 100)
  name: String               @input_maxLength(f: "name", n: 100)
  password: String! @hidden  @input_maxLength(f: "password", n: 100)
  roles: [Node!] @hasInverse(field: first_link) @input_ensureType(f: "roles", t: Role)
  backed_roles: [Node!] @hasInverse(field: second_link) @input_ensureType(f: "backed_roles", t: Role)
  bio: String
  utc: String
  #skills
}

#
# Labels
#

type Label {
  id: ID!
  name: String! @id 
  color: String
  #project: Project...
}



#
# Enum
#

enum NodeType {
  Circle
  Role
}

enum TensionType {
  Governance
  Operational
  Personal
  Help
  # Alert # BotAlert 
  # Poll ?
}

enum RoleType {
  Coordinator
  Member
  Guest # where invited and member with no roles goes
  #Retired
}

