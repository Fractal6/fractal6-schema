# <!> Code depencies:
# * fractal6.go/web/auth/model: reference to typeName
# * fractal6.go/web/auth/dgraph: when typeName is invoked
# * fractal6-ui.elm: case on enumeration object (NodeType, TensionType ,etc)

#
# Node Interface
#
type Node {
  id: ID!
  createdAt: DateTime! @search @inputP_RO
  createdBy: User! @inputP_RO


  # Node linking
  
  root: Node!
  # If parent is null, Node is a root node !
  parent: Node @input_hasRole(n:["parent"], r:Coordinator)
  # @DEBUG union for multi edge graph
  children: [Node!] @hasInverse(field: parent) @input_hasRole(n:["parent"], r:Coordinator)
  type_: NodeType! @search @input_hasRole(n:["parent"], r: Coordinator)

  # Node naming/ID
 
  # Index nodes nameid since its an open issue 
  # to recursively get children object in GraphQL.
  nameid: String! @id  @inputP_RO # Used for URI
  name: String! @search(by: [term]) @input_hasRole(n:["parent"], r:Coordinator)
  rootnameid: String! @search(by: [hash]) @inputP_RO

  ### Node Data/attributes
 
  mandate: Mandate @input_hasRole(n:["parent"], r:Coordinator)
  # validatedBy  # @DEBUG: Birth logics?
  
  tensions_out: [Tension!] @hasInverse(field: emitter) @inputP_RO
  tensions_in: [Tension!] @hasInverse(field: receiver) @inputP_RO

  n_tensions_out: Int @count(f: tensions_out)
  n_tensions_in: Int @count(f: tensions_in)
  n_children: Int @count(f: children)

  # Circle...
  isRoot: Boolean! @search @inputP_RO

  # Role...
  first_link: User @input_hasRole(n:["parent"], r:Coordinator)
  second_link: User @input_hasRole(n:["parent"], r:Coordinator)
  skills: [String!] @search(by: [term]) @input_hasRole(n:["parent"], r:Coordinator)
  role_type: RoleType @input_hasRole(n:["parent"], r:Coordinator) # <- default to guest when union supported
}

# @Debug(#3a99e49): when **union** will be available in Draph
# Considered using a union for Role = Circle | Role and _Role interface for both.
# ...
## Supernode/Hyperedge
#type Circle implements Node {
#  isRoot: Boolean! @search
#}
#
## Leaf
#type Role implements Node {
#  first_link: User
#  second_link: User
#  skills: [String!] @search(by: [term])
#  #authority: Authority
#}

#
# Post Interface
#
interface Post {
  id: ID!
  createdAt: DateTime! @search @inputP_RO
  createdBy: User!             @inputP_RO
  message: String @search(by: [fulltext]) @inputP_isOwner(u:"createdBy")
}


type Tension implements Post {
  #isAnonymous: Boolean!
  nth: String     @search # @id...Upsert in BLL / Used for URI
  title: String!  @search(by: [term])  @input_hasRole(n:["emitter"], r:Coordinator, u:"createdBy")
  type_: TensionType!  @search  @input_hasRole(n:["emitter"], r:Coordinator, u:"createdBy")
  emitter: Node!   @input_hasRoot(n:["emitter"])  @inputP_RO
  receiver: Node!  @input_hasRoot(n:["receiver"])  @input_hasRole(n:["receiver"], r:Coordinator, u:"createdBy")
  comments: [Comment!]  @input_hasRoot(n:["emitter", "receiver"])
  labels: [Label!]  @input_hasRole(n:["emitter", "receiver"], r:Coordinator, u:"createdBy")

  # Automatic field
  n_comments: Int  @count(f: comments)
}


type Comment implements Post {
  message: String! @search(by: [fulltext]) @inputP_isOwner(u:"createdBy")
}

type Mandate implements Post {
  purpose: String! @search(by: [fulltext]) @inputP_RO
  responsabilities: Post @inputP_RO
  domains: Post @inputP_RO
  # Interface:
  #    period:
  #    canValidateNode
  #    number of validation to be modified ? ....
  #    election ???
}

#
# User
#

type User {
  id: ID!
  createdAt: DateTime!  @inputP_RO
  username: String! @id @inputP_RO @input_maxLength(f:"username", n:42)
  # @DEBUG: several @id currentlynot allowed !
  # Q: how to enfore uniqueness ?
  email: String! @hidden @inputP_isOwner @search(by: [hash]) @input_maxLength(f:"email", n:100)
  emailHash: String @hidden @inputP_RO
  emailValidated: Boolean! @hidden @inputP_RO
  #email: String! @id @hidden @input_maxLength(f: "email", n: 100)
  name: String              @inputP_isOwner @input_maxLength(f:"name", n:100)
  password: String! @hidden @inputP_isOwner @input_maxLength(f:"password", n:100)
  roles: [Node!] @hasInverse(field: first_link)         @inputP_RO @input_ensureType(f:"roles", t:Role)
  backed_roles: [Node!] @hasInverse(field: second_link) @inputP_RO @input_ensureType(f:"backed_roles", t:Role)
  bio: String @inputP_isOwner
  utc: String @inputP_isOwner
  #skills
}

#
# Labels
#

type Label {
  id: ID!
  name: String! @id 
  color: String
  #project: Project...
}



#
# Enum
#

enum NodeType {
  Circle
  Role
}

enum TensionType {
  Governance
  Operational
  Personal
  Help
  # Alert # BotAlert. Circle can emit tension ?
  # Poll ?
}

enum RoleType {
  Coordinator
  Member
  Guest # where invited and member with no roles goes
  #Retired
}

